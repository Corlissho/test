<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>2048 平滑動畫遊戲</title>

<style>
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
  background: linear-gradient(135deg, #667eea, #764ba2);
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  color: white;
  user-select: none;
  touch-action: none;
  overflow: hidden;
}

.game-container {
  width: 480px;
  max-width: 95vw;
  padding: 20px;
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.title {
  font-size: 48px;
  font-weight: 800;
  color: #f9f6f2;
  text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.scores-container {
  display: flex;
  gap: 10px;
}

.score-box, .best-box {
  background: rgba(255, 255, 255, 0.15);
  padding: 12px 20px;
  border-radius: 10px;
  text-align: center;
  min-width: 100px;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.score-label, .best-label {
  font-size: 14px;
  opacity: 0.9;
  margin-bottom: 5px;
}

.score-value, .best-value {
  font-size: 24px;
  font-weight: 700;
}

.controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 20px;
  flex-wrap: wrap;
  gap: 10px;
}

.restart-btn {
  background: #8f7a66;
  color: white;
  border: none;
  padding: 12px 24px;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.restart-btn:hover {
  background: #9c8a7a;
  transform: translateY(-2px);
}

.restart-btn:active {
  transform: translateY(0);
}

.instructions {
  font-size: 14px;
  opacity: 0.8;
  text-align: center;
  margin-bottom: 10px;
}

.board {
  position: relative;
  background: rgba(255, 255, 255, 0.1);
  padding: 15px;
  border-radius: 12px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.15);
}

.grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
  gap: 12px;
  width: 100%;
  aspect-ratio: 1 / 1;
  position: relative;
}

.cell {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 8px;
  position: relative;
}

.tile {
  position: absolute;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  font-size: 32px;
  z-index: 10;
  transition: transform 0.15s ease-out, opacity 0.15s ease-out;
  will-change: transform, left, top;
  user-select: none;
  overflow: hidden;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.tile-inner {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
}

.tile.merged {
  animation: merge-pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  z-index: 20;
}

.tile.new {
  animation: appear 0.2s ease-out;
}

@keyframes appear {
  0% {
    opacity: 0;
    transform: scale(0.5);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

@keyframes merge-pop {
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.2);
  }
  100% {
    transform: scale(1);
  }
}

@keyframes bounce {
  0%, 100% {
    transform: scale(1);
  }
  30% {
    transform: scale(1.1);
  }
  60% {
    transform: scale(0.95);
  }
}

.game-over {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  z-index: 100;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s, visibility 0.3s;
}

.game-over.show {
  opacity: 1;
  visibility: visible;
}

.game-over-message {
  font-size: 36px;
  font-weight: 700;
  margin-bottom: 20px;
  color: #f9f6f2;
}

.game-over-score {
  font-size: 24px;
  margin-bottom: 30px;
  color: #eee;
}

.continue-btn {
  background: #8f7a66;
  color: white;
  border: none;
  padding: 15px 30px;
  border-radius: 8px;
  font-size: 18px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.continue-btn:hover {
  background: #9c8a7a;
  transform: scale(1.05);
}

.tile-color-2 { background: #eee4da; color: #776e65; }
.tile-color-4 { background: #ede0c8; color: #776e65; }
.tile-color-8 { background: #f2b179; color: #f9f6f2; }
.tile-color-16 { background: #f59563; color: #f9f6f2; }
.tile-color-32 { background: #f67c5f; color: #f9f6f2; }
.tile-color-64 { background: #f65e3b; color: #f9f6f2; }
.tile-color-128 { background: #edcf72; color: #f9f6f2; font-size: 28px; }
.tile-color-256 { background: #edcc61; color: #f9f6f2; font-size: 28px; }
.tile-color-512 { background: #edc850; color: #f9f6f2; font-size: 28px; }
.tile-color-1024 { background: #edc53f; color: #f9f6f2; font-size: 24px; }
.tile-color-2048 { background: #edc22e; color: #f9f6f2; font-size: 24px; }
.tile-color-super { background: #3c3a32; color: #f9f6f2; font-size: 20px; }

@media (max-width: 520px) {
  .game-container {
    width: 100%;
    padding: 10px;
  }
  
  .title {
    font-size: 36px;
  }
  
  .score-box, .best-box {
    min-width: 80px;
    padding: 10px 15px;
  }
  
  .score-value, .best-value {
    font-size: 20px;
  }
  
  .tile {
    font-size: 24px;
  }
  
  .tile-color-128,
  .tile-color-256,
  .tile-color-512 {
    font-size: 20px;
  }
  
  .tile-color-1024,
  .tile-color-2048 {
    font-size: 18px;
  }
}
</style>
</head>
<body>

<div class="game-container">
  <div class="header">
    <div class="title">2048</div>
    <div class="scores-container">
      <div class="score-box">
        <div class="score-label">分數</div>
        <div class="score-value" id="score">0</div>
      </div>
      <div class="best-box">
        <div class="best-label">最佳分數</div>
        <div class="best-value" id="best">0</div>
      </div>
    </div>
  </div>
  
  <div class="controls">
    <button class="restart-btn" id="restart">重新開始</button>
    <div class="instructions">
      使用方向鍵或滑動來移動方塊
    </div>
  </div>
  
  <div class="board" id="board">
    <div class="grid" id="grid">
      <!-- 16 cells will be generated by JavaScript -->
    </div>
    
    <div class="game-over" id="gameOver">
      <div class="game-over-message">遊戲結束！</div>
      <div class="game-over-score">最終分數: <span id="finalScore">0</span></div>
      <button class="continue-btn" id="continueBtn">再玩一次</button>
    </div>
  </div>
</div>

<script>
// Game constants
const GRID_SIZE = 4;
const CELL_GAP = 12;
const ANIMATION_DURATION = 150;

// Game state
let grid = [];
let score = 0;
let bestScore = 0;
let isAnimating = false;
let gameOver = false;
let tiles = [];

// DOM elements
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const restartBtn = document.getElementById('restart');
const gameOverEl = document.getElementById('gameOver');
const finalScoreEl = document.getElementById('finalScore');
const continueBtn = document.getElementById('continueBtn');

// Initialize game
function init() {
  // Load best score from localStorage
  bestScore = parseInt(localStorage.getItem('2048-best-score')) || 0;
  bestEl.textContent = bestScore;
  
  // Create grid cells
  gridEl.innerHTML = '';
  gridEl.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 1fr)`;
  gridEl.style.gridTemplateRows = `repeat(${GRID_SIZE}, 1fr)`;
  gridEl.style.gap = `${CELL_GAP}px`;
  
  for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    gridEl.appendChild(cell);
  }
  
  // Initialize grid array
  grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
  
  // Reset game state
  score = 0;
  gameOver = false;
  isAnimating = false;
  tiles = [];
  
  // Remove all tiles from DOM
  document.querySelectorAll('.tile').forEach(tile => tile.remove());
  
  // Update score display
  updateScore();
  
  // Hide game over screen
  gameOverEl.classList.remove('show');
  
  // Spawn initial tiles
  spawnTile();
  spawnTile();
  
  // Render initial state
  renderTiles();
}

// Spawn a new tile in a random empty cell
function spawnTile() {
  const emptyCells = [];
  
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      if (grid[r][c] === 0) {
        emptyCells.push({ r, c });
      }
    }
  }
  
  if (emptyCells.length === 0) return false;
  
  const { r, c } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
  const value = Math.random() < 0.9 ? 2 : 4;
  
  grid[r][c] = value;
  
  // Create tile object for animation tracking
  const tile = {
    id: `${r}-${c}-${Date.now()}`,
    r, c, value,
    mergedFrom: null,
    isNew: true
  };
  
  tiles.push(tile);
  return true;
}

// Render all tiles with proper positioning
function renderTiles(animate = true) {
  const boardRect = gridEl.getBoundingClientRect();
  const cellSize = (boardRect.width - CELL_GAP * (GRID_SIZE - 1)) / GRID_SIZE;
  
  // Remove tiles that are no longer in the grid
  const currentTileIds = tiles.map(t => t.id);
  document.querySelectorAll('.tile').forEach(tileEl => {
    if (!currentTileIds.includes(tileEl.dataset.id)) {
      tileEl.remove();
    }
  });
  
  // Create or update tiles
  tiles.forEach(tile => {
    let tileEl = document.querySelector(`.tile[data-id="${tile.id}"]`);
    
    if (!tileEl) {
      tileEl = document.createElement('div');
      tileEl.className = 'tile';
      tileEl.dataset.id = tile.id;
      
      const inner = document.createElement('div');
      inner.className = 'tile-inner';
      inner.textContent = tile.value;
      tileEl.appendChild(inner);
      
      gridEl.appendChild(tileEl);
      
      // Set initial position (for new tiles)
      tileEl.style.width = `${cellSize}px`;
      tileEl.style.height = `${cellSize}px`;
      tileEl.style.left = `${tile.c * (cellSize + CELL_GAP)}px`;
      tileEl.style.top = `${tile.r * (cellSize + CELL_GAP)}px`;
      
      // Set color class
      tileEl.classList.add(`tile-color-${tile.value}`);
      if (tile.value > 2048) tileEl.classList.add('tile-color-super');
      
      // Add new tile animation
      if (tile.isNew) {
        tileEl.classList.add('new');
        tile.isNew = false;
      }
    }
    
    // Calculate target position - add board padding offset
    const targetLeft = tile.c * (cellSize + CELL_GAP);
    const targetTop = tile.r * (cellSize + CELL_GAP);
    
    // Get current position
    const currentLeft = parseFloat(tileEl.style.left) || targetLeft;
    const currentTop = parseFloat(tileEl.style.top) || targetTop;
    
    // If position changed, animate
    if (animate && (currentLeft !== targetLeft || currentTop !== targetTop)) {
      // Set transition for smooth movement
      tileEl.style.transition = `left ${ANIMATION_DURATION}ms ease-out, top ${ANIMATION_DURATION}ms ease-out`;
      tileEl.style.left = `${targetLeft}px`;
      tileEl.style.top = `${targetTop}px`;
    } else {
      // No animation, set directly
      tileEl.style.transition = 'none';
      tileEl.style.left = `${targetLeft}px`;
      tileEl.style.top = `${targetTop}px`;
    }
    
    // Update value if changed
    if (tileEl.querySelector('.tile-inner').textContent !== String(tile.value)) {
      tileEl.querySelector('.tile-inner').textContent = tile.value;
      tileEl.className = 'tile'; // Reset classes
      tileEl.classList.add(`tile-color-${tile.value}`);
      if (tile.value > 2048) tileEl.classList.add('tile-color-super');
      
      // Add merge animation
      if (tile.mergedFrom) {
        tileEl.classList.add('merged');
        setTimeout(() => {
          tileEl.classList.remove('merged');
        }, 300);
        tile.mergedFrom = null;
      }
    }
  });
}

// Update score display
function updateScore() {
  scoreEl.textContent = score;
  
  if (score > bestScore) {
    bestScore = score;
    bestEl.textContent = bestScore;
    localStorage.setItem('2048-best-score', bestScore.toString());
  }
}

// Check if game is over
function checkGameOver() {
  // If there are empty cells, game is not over
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      if (grid[r][c] === 0) return false;
    }
  }
  
  // Check for possible merges
  for (let r = 0; r < GRID_SIZE; r++) {
    for (let c = 0; c < GRID_SIZE; c++) {
      const current = grid[r][c];
      
      // Check right neighbor
      if (c < GRID_SIZE - 1 && grid[r][c + 1] === current) return false;
      
      // Check bottom neighbor
      if (r < GRID_SIZE - 1 && grid[r + 1][c] === current) return false;
    }
  }
  
  return true;
}

// Move tiles in a specific direction
function move(direction) {
if (isAnimating || gameOver) return false;

let moved = false;
const vectors = {
'left': { x: 0, y: -1 },
'right': { x: 0, y: 1 },
'up': { x: -1, y: 0 },
'down': { x: 1, y: 0 }
};

const vector = vectors[direction];
if (!vector) return false;

// Prepare for animation
isAnimating = true;

// Create a copy of the grid to track merges
const merged = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));

// Determine traversal order based on direction
const rowOrder = vector.x === 1 ?
[...Array(GRID_SIZE).keys()].reverse() :
[...Array(GRID_SIZE).keys()];

const colOrder = vector.y === 1 ?
[...Array(GRID_SIZE).keys()].reverse() :
[...Array(GRID_SIZE).keys()];

// Process each tile in the correct order
for (const r of rowOrder) {
for (const c of colOrder) {
  if (grid[r][c] === 0) continue;
  
  let currentR = r;
  let currentC = c;
  let movedThisTile = false;
  
  // Move tile as far as possible
  while (true) {
    const nextR = currentR + vector.x;
    const nextC = currentC + vector.y;
    
    // Check bounds
    if (nextR < 0 || nextR >= GRID_SIZE || nextC < 0 || nextC >= GRID_SIZE) {
      break;
    }
    
    // Check if next cell is empty
    if (grid[nextR][nextC] === 0) {
      // Move tile to empty cell
      grid[nextR][nextC] = grid[currentR][currentC];
      grid[currentR][currentC] = 0;
      
      // Update tile position in tiles array
      const tile = tiles.find(t => t.r === currentR && t.c === currentC);
      if (tile) {
        tile.r = nextR;
        tile.c = nextC;
      }
      
      currentR = nextR;
      currentC = nextC;
      moved = true;
      movedThisTile = true;
    }
    // Check if we can merge with next cell
    else if (grid[nextR][nextC] === grid[currentR][currentC] && !merged[nextR][nextC]) {
      // Merge tiles
      const newValue = grid[nextR][nextC] * 2;
      grid[nextR][nextC] = newValue;
      grid[currentR][currentC] = 0;
      
      // Update score
      score += newValue;
      
      // Mark as merged
      merged[nextR][nextC] = true;
      
      // Update tile in tiles array (remove old, update new)
      const oldTileIndex = tiles.findIndex(t => t.r === currentR && t.c === currentC);
      if (oldTileIndex !== -1) {
        tiles.splice(oldTileIndex, 1);
      }
      
      const newTile = tiles.find(t => t.r === nextR && t.c === nextC);
      if (newTile) {
        newTile.value = newValue;
        newTile.mergedFrom = true;
      }
      
      moved = true;
      movedThisTile = true;
      break;
    } else {
      // Can't move further
      break;
    }
  }
  
  // If tile moved, update its position in tiles array
  if (movedThisTile) {
    const tile = tiles.find(t =>
      (t.r === currentR && t.c === currentC) ||
      (t.r === r && t.c === c && t.r !== currentR && t.c !== currentC)
    );
    if (tile && (tile.r !== currentR || tile.c !== currentC)) {
      tile.r = currentR;
      tile.c = currentC;
    }
  }
}
}

// If any tiles moved, spawn a new tile and render
if (moved) {
// Render with animation
renderTiles(true);

// Wait for animation to complete before spawning new tile
setTimeout(() => {
  spawnTile();
  renderTiles(true);
  updateScore();
  
  // Check for game over
  if (checkGameOver()) {
    setTimeout(() => {
      gameOver = true;
      finalScoreEl.textContent = score;
      gameOverEl.classList.add('show');
    }, ANIMATION_DURATION + 50);
  }
  
  isAnimating = false;
}, ANIMATION_DURATION);
} else {
isAnimating = false;
}

return moved;
}

// Keyboard controls
document.addEventListener('keydown', (e) => {
if (e.key === 'ArrowLeft') move('left');
else if (e.key === 'ArrowRight') move('right');
else if (e.key === 'ArrowUp') move('up');
else if (e.key === 'ArrowDown') move('down');
});

// Touch/swipe controls
let touchStartX = 0;
let touchStartY = 0;
let touchEndX = 0;
let touchEndY = 0;

const board = document.getElementById('board');

board.addEventListener('touchstart', (e) => {
touchStartX = e.touches[0].clientX;
touchStartY = e.touches[0].clientY;
e.preventDefault();
}, { passive: false });

board.addEventListener('touchmove', (e) => {
e.preventDefault();
}, { passive: false });

board.addEventListener('touchend', (e) => {
touchEndX = e.changedTouches[0].clientX;
touchEndY = e.changedTouches[0].clientY;

const dx = touchEndX - touchStartX;
const dy = touchEndY - touchStartY;
const minSwipeDistance = 30;

// Determine swipe direction
if (Math.abs(dx) > Math.abs(dy)) {
// Horizontal swipe
if (Math.abs(dx) > minSwipeDistance) {
  if (dx > 0) move('right');
  else move('left');
}
} else {
// Vertical swipe
if (Math.abs(dy) > minSwipeDistance) {
  if (dy > 0) move('down');
  else move('up');
}
}

e.preventDefault();
}, { passive: false });

// Button event listeners
restartBtn.addEventListener('click', init);
continueBtn.addEventListener('click', init);

// Initialize the game
init();

// Add bounce animation to merged tiles periodically for demonstration
setInterval(() => {
  document.querySelectorAll('.tile.merged').forEach(tile => {
    tile.style.animation = 'bounce 0.5s ease';
    setTimeout(() => {
      tile.style.animation = '';
    }, 500);
  });
}, 3000);

</script>
</body>
</html>
