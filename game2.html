    <div class="game-info">
        <div class="player-info player-red current-player" id="player-red">
            <div class="player-title">
                <span class="player-icon"></span>
                玩家 紅方
            </div>
            <div class="status-item">
                <span class="status-label">起飛:</span>
                <span class="status-value" id="ready-red">0/4</span>
            </div>
            <div class="status-item">
                <span class="status-label">完成:</span>
                <span class="status-value" id="finished-red">0/4</span>
            </div>
        </div>
        
        <div class="player-info player-blue" id="player-blue">
            <div class="player-title">
                <span class="player-icon"></span>
                玩家 藍方
            </div>
            <div class="status-item">
                <span class="status-label">起飛:</span>
                <span class="status-value" id="ready-blue">0/4</span>
            </div>
            <div class="status-item">
                <span class="status-label">完成:</span>
                <span class="status-value" id="finished-blue">0/4</span>
            </div>
        </div>
        
        <div class="player-info player-yellow" id="player-yellow">
            <div class="player-title">
                <span class="player-icon"></span>
                玩家 黃方
            </div>
            <div class="status-item">
                <span class="status-label">起飛:</span>
                <span class="status-value" id="ready-yellow">0/4</span>
            </div>
            <div class="status-item">
                <span class="status-label">完成:</span>
                <span class="status-value" id="finished-yellow">0/4</span>
            </div>
        </div>
        
        <div class="player-info player-green" id="player-green">
            <div class="player-title">
                <span class="player-icon"></span>
                電腦 綠方
            </div>
            <div class="status-item">
                <span class="status-label">起飛:</span>
                <span class="status-value" id="ready-green">0/4</span>
            </div>
            <div class="status-item">
                <span class="status-label">完成:</span>
                <span class="status-value" id="finished-green">0/4</span>
            </div>
        </div>
    </div>
    
    <div class="game-board">
        <div class="board-grid" id="board"></div>
    </div>
    
    <div class="dice-container">
        <div class="dice" id="dice">?</div>
    </div>
    
    <div class="action-buttons">
        <button class="btn btn-roll" id="roll-btn">擲骰子</button>
        <button class="btn btn-skip" id="skip-btn" disabled>跳過回合</button>
    </div>
    
    <div class="game-status" id="status">紅方玩家，請擲骰子開始遊戲！</div>
</div>

<script>
    // 遊戲狀態
    const gameState = {
        currentPlayer: 'red', // 'red', 'yellow', 'blue', 'green'
        diceValue: 0,
        boardSize: 15,
        homePositions: {
            red: { row: 1, col: 1 },
            yellow: { row: 1, col: 11 },
            blue: { row: 11, col: 11 },
            green: { row: 11, col: 1 }
        },
        startPositions: {
            red: { row: 6, col: 1 },
            yellow: { row: 1, col: 8 },
            blue: { row: 8, col: 14 },
            green: { row: 14, col: 7 }
        },
        safePositions: [
            { row: 6, col: 1 }, { row: 1, col: 8 }, { row: 8, col: 14 }, { row: 14, col: 7 },
            { row: 6, col: 7 }, { row: 7, col: 8 }, { row: 8, col: 8 }, { row: 8, col: 7 }
        ],
        finishPaths: {
            red: [
                { row: 6, col: 2 }, { row: 6, col: 3 }, { row: 6, col: 4 },
                { row: 6, col: 5 }, { row: 6, col: 6 }, { row: 6, col: 7 }
            ],
            yellow: [
                { row: 2, col: 8 }, { row: 3, col: 8 }, { row: 4, col: 8 },
                { row: 5, col: 8 }, { row: 6, col: 8 }, { row: 7, col: 8 }
            ],
            blue: [
                { row: 8, col: 13 }, { row: 8, col: 12 }, { row: 8, col: 11 },
                { row: 8, col: 10 }, { row: 8, col: 9 }, { row: 8, col: 8 }
            ],
            green: [
                { row: 13, col: 7 }, { row: 12, col: 7 }, { row: 11, col: 7 },
                { row: 10, col: 7 }, { row: 9, col: 7 }, { row: 8, col: 7 }
            ]
        },
        players: {
            red: { pieces: [0, 0, 0, 0], started: [false, false, false, false], finished: [false, false, false, false] },
            yellow: { pieces: [0, 0, 0, 0], started: [false, false, false, false], finished: [false, false, false, false] },
            blue: { pieces: [0, 0, 0, 0], started: [false, false, false, false], finished: [false, false, false, false] },
            green: { pieces: [0, 0, 0, 0], started: [false, false, false, false], finished: [false, false, false, false] }
        },
        path: [],
        canRoll: true,
        extraTurn: false,
        playerNames: {
            red: '紅方',
            yellow: '黃方',
            blue: '藍方',
            green: '綠方'
        },
        waitingForMove: false,
        boardElement: null,
        diceElement: null,
        rollButton: null,
        skipButton: null,
        statusElement: null,
        winner: null
    };
    
    // 初始化遊戲
    function initGame() {
        gameState.boardElement = document.getElementById('board');
        gameState.diceElement = document.getElementById('dice');
        gameState.rollButton = document.getElementById('roll-btn');
        gameState.skipButton = document.getElementById('skip-btn');
        gameState.statusElement = document.getElementById('status');
        
        createBoard();
        renderPieces();
        setupEventListeners();
    }
    
    // 創建棋盤
    function createBoard() {
        gameState.boardElement.innerHTML = '';
        const boardSize = gameState.boardSize;
        
        // 創建路徑
        createPath();
        
        // 生成所有格子
        for (let row = 0; row < boardSize; row++) {
            for (let col = 0; col < boardSize; col++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = row;
                cell.dataset.col = col;
                
                // 設置家園位置
                if ((row >= 1 && row <= 3 && col >= 1 && col <= 3) ||
                    (row >= 1 && row <= 3 && col >= 11 && col <= 13) ||
                    (row >= 11 && row <= 13 && col >= 11 && col <= 13) ||
                    (row >= 11 && row <= 13 && col >= 1 && col <= 3)) {
                    
                    if (row >= 1 && row <= 3 && col >= 1 && col <= 3) {
                        cell.className += ' home-base home-red';
                    } else if (row >= 1 && row <= 3 && col >= 11 && col <= 13) {
                        cell.className += ' home-base home-yellow';
                    } else if (row >= 11 && row <= 13 && col >= 11 && col <= 13) {
                        cell.className += ' home-base home-blue';
                    } else if (row >= 11 && row <= 13 && col >= 1 && col <= 3) {
                        cell.className += ' home-base home-green';
                    }
                }
                
                // 設置起點
                if ((row === 6 && col === 1) || (row === 1 && col === 8) || 
                    (row === 8 && col === 14) || (row === 14 && col === 7)) {
                    cell.className += ' start-cell';
                }
                
                // 設置安全點
                gameState.safePositions.forEach(pos => {
                    if (row === pos.row && col === pos.col) {
                        cell.className += ' safe-cell';
                    }
                });
                
                // 設置終點路徑
                Object.entries(gameState.finishPaths).forEach(([color, path]) => {
                    const finishColor = `finish-${color}`;
                    path.forEach(pos => {
                        if (row === pos.row && col === pos.col) {
                            cell.className += ` finish-path ${finishColor}`;
                        }
                    });
                });
                
                gameState.boardElement.appendChild(cell);
            }
        }
    }
    
    // 創建路徑
    function createPath() {
        const path = [];
        const boardSize = gameState.boardSize;
        
        // 頂部路徑 (左到右)
        for (let col = 1; col < boardSize - 1; col++) {
            if (col !== 8) { // 跳過黃色起點
                path.push({ row: 0, col: col });
            }
        }
        
        // 右側路徑 (上到下)
        for (let row = 1; row < boardSize - 1; row++) {
            if (row !== 8) { // 跳過藍色起點
                path.push({ row: row, col: boardSize - 1 });
            }
        }
        
        // 底部路徑 (右到左)
        for (let col = boardSize - 2; col > 0; col--) {
            if (col !== 7) { // 跳過綠色起點
                path.push({ row: boardSize - 1, col: col });
            }
        }
        
        // 左側路徑 (下到上)
        for (let row = boardSize - 2; row > 0; row--) {
            if (row !== 6) { // 跳過紅色起點
                path.push({ row: row, col: 0 });
            }
        }
        
        gameState.path = path;
    }
    
    // 渲染棋子
    function renderPieces() {
        // 移除現有的棋子
        document.querySelectorAll('.piece').forEach(piece => piece.remove());
        
        // 渲染所有玩家的棋子
        Object.entries(gameState.players).forEach(([color, player]) => {
            player.pieces.forEach((position, index) => {
                if (player.finished[index]) {
                    // 已完成的棋子放在終點區域
                    const finishPath = gameState.finishPaths[color];
                    if (finishPath.length > 0) {
                        const finishPosition = finishPath[finishPath.length - 1];
                        createPiece(color, index, finishPosition.row, finishPosition.col, true);
                    }
                    return;
                }
                
                if (player.started[index]) {
                    // 已起飛的棋子在路徑上
                    if (position < gameState.path.length) {
                        const pos = gameState.path[position];
                        createPiece(color, index, pos.row, pos.col);
                    } else {
                        // 進入終點路徑
                        const finishIndex = position - gameState.path.length;
                        const finishPath = gameState.finishPaths[color];
                        
                        if (finishIndex < finishPath.length) {
                            const pos = finishPath[finishIndex];
                            createPiece(color, index, pos.row, pos.col);
                        }
                    }
                } else {
                    // 在家園中的棋子
                    const homePos = gameState.homePositions[color];
                    const offsets = [
                        { row: 0, col: 0 },
                        { row: 0, col: 2 },
                        { row: 2, col: 0 },
                        { row: 2, col: 2 }
                    ];
                    
                    const offset = offsets[index];
                    createPiece(color, index, homePos.row + offset.row, homePos.col + offset.col, true);
                }
            });
        });
        
        // 更新狀態
        updateStatus();
    }
    
    // 創建單個棋子
    function createPiece(color, pieceIndex, row, col, inHome = false) {
        const piece = document.createElement('div');
        piece.className = `piece piece-${color} ${inHome ? 'in-home' : ''}`;
        piece.dataset.color = color;
        piece.dataset.pieceIndex = pieceIndex;
        piece.innerHTML = pieceIndex + 1;
        piece.style.top = `${row * (100 / gameState.boardSize)}%`;
        piece.style.left = `${col * (100 / gameState.boardSize)}%`;
        
        if (inHome) {
            piece.style.transform = 'translate(-50%, -50%) scale(0.7)';
        } else {
            piece.style.transform = 'translate(-50%, -50%)';
        }
        
        const boardRect = gameState.boardElement.getBoundingClientRect();
        const cellSize = boardRect.width / gameState.boardSize;
        piece.style.width = `${cellSize * 0.7}px`;
        piece.style.height = `${cellSize * 0.7}px`;
        
        // 只為人類玩家的棋子添加點擊事件
        if (color !== 'green' || gameState.currentPlayer === 'green') {
            piece.addEventListener('click', () => handlePieceClick(color, pieceIndex));
        }
        
        gameState.boardElement.appendChild(piece);
    }
    
    // 處理棋子點擊
    function handlePieceClick(color, pieceIndex) {
        if (!gameState.waitingForMove || gameState.currentPlayer !== color || gameState.winner) return;
        
        const player = gameState.players[color];
        
        // 檢查這顆棋子是否可以移動
        if (!canMovePiece(color, pieceIndex)) {
            showStatus(`這顆棋子無法移動！`);
            return;
        }
        
        movePiece(color, pieceIndex, gameState.diceValue);
        checkForKnockouts(color, pieceIndex);
        
        // 檢查是否完成
        checkWinCondition();
        
        if (gameState.winner) {
            showWinner(gameState.winner);
            return;
        }
        
        // 檢查是否需要額外回合
        if (!gameState.extraTurn) {
            nextPlayer();
        } else {
            gameState.extraTurn = false;
            showStatus(`${gameState.playerNames[gameState.currentPlayer]} 擊落對手，獲得額外回合！`);
            gameState.waitingForMove = false;
            gameState.canRoll = true;
            enableRollButton();
        }
    }
    
    // 檢查棋子是否可以移動
    function canMovePiece(color, pieceIndex) {
        const player = gameState.players[color];
        const piecePos = player.pieces[pieceIndex];
        
        // 尚未起飛
        if (!player.started[pieceIndex]) {
            return gameState.diceValue === 6;
        }
        
        // 已完成
        if (player.finished[pieceIndex]) {
            return false;
        }
        
        // 檢查移動後是否會超出終點
        const finishPath = gameState.finishPaths[color];
        const pathLength = gameState.path.length;
        
        if (piecePos >= pathLength) {
            // 已經在終點路徑上
            const finishIndex = piecePos - pathLength;
            return finishIndex + gameState.diceValue < finishPath.length;
        }
        
        return true;
    }
    
    // 移動棋子
    function movePiece(color, pieceIndex, steps) {
        const player = gameState.players[color];
        
        if (!player.started[pieceIndex]) {
            // 起飛
            player.started[pieceIndex] = true;
            player.pieces[pieceIndex] = 0;
            
            // 如果第一次擲到6，可以再擲一次
            if (gameState.diceValue === 6) {
                gameState.extraTurn = true;
            }
        } else {
            // 在路徑上移動
            const currentPosition = player.pieces[pieceIndex];
            const newPathPosition = currentPosition + steps;
            const pathLength = gameState.path.length;
            const finishPath = gameState.finishPaths[color];
            
            if (currentPosition < pathLength && newPathPosition >= pathLength) {
                // 進入終點路徑
                const finishSteps = newPathPosition - pathLength;
                
                if (finishSteps < finishPath.length) {
                    player.pieces[pieceIndex] = pathLength + finishSteps;
                    
                    // 檢查是否完成
                    if (finishSteps === finishPath.length - 1) {
                        player.finished[pieceIndex] = true;
                        showStatus(`太棒了！${gameState.playerNames[color]} 的 ${pieceIndex + 1} 號飛機到達終點！`);
                    }
                }
            } else if (currentPosition >= pathLength) {
                // 在終點路徑上
                const finishIndex = currentPosition - pathLength;
                const newFinishIndex = finishIndex + steps;
                
                if (newFinishIndex < finishPath.length) {
                    player.pieces[pieceIndex] = pathLength + newFinishIndex;
                    
                    // 檢查是否完成
                    if (newFinishIndex === finishPath.length - 1) {
                        player.finished[pieceIndex] = true;
                        showStatus(`太棒了！${gameState.playerNames[color]} 的 ${pieceIndex + 1} 號飛機到達終點！`);
                    }
                }
            } else {
                // 在主路徑上
                player.pieces[pieceIndex] = newPathPosition % pathLength;
            }
        }
        
        renderPieces();
    }
    
    // 檢查並處理擊落
    function checkForKnockouts(currentColor, movedPieceIndex) {
        const currentPlayer = gameState.players[currentColor];
        const movedPiecePos = currentPlayer.pieces[movedPieceIndex];
        
        // 只有在主路徑上才會擊落
        if (movedPiecePos >= gameState.path.length) return;
        
        const currentPos = gameState.path[movedPiecePos];
        let knockedOut = false;
        
        // 檢查其他所有玩家的棋子
        Object.entries(gameState.players).forEach(([color, player]) => {
            if (color === currentColor) return;
            
            player.pieces.forEach((pos, index) => {
                if (player.finished[index] || !player.started[index]) return;
                
                // 檢查是否在同一個位置
                if (pos < gameState.path.length) {
                    const otherPos = gameState.path[pos];
                    
                    if (currentPos.row === otherPos.row && currentPos.col === otherPos.col) {
                        // 檢查是否是安全位置
                        const isSafe = gameState.safePositions.some(
                            safePos => safePos.row === currentPos.row && safePos.col === currentPos.col
                        );
                        
                        if (!isSafe) {
                            // 擊落對手
                            player.started[index] = false;
                            player.pieces[index] = 0;
                            knockedOut = true;
                            showStatus(`${gameState.playerNames[currentColor]} 擊落了 ${gameState.playerNames[color]} 的飛機！`);
                        }
                    }
                }
            });
        });
        
        if (knockedOut) {
            gameState.extraTurn = true;
        }
    }
    
    // 檢查贏的條件
    function checkWinCondition() {
        Object.entries(gameState.players).forEach(([color, player]) => {
            if (player.finished.every(finished => finished) && !gameState.winner) {
                gameState.winner = color;
            }
        });
    }
    
    // 電腦移動
    function computerMove() {
        if (gameState.currentPlayer !== 'green' || gameState.winner) return;
        
        setTimeout(() => {
            const availableMoves = getAvailableMoves('green');
            
            if (availableMoves.length === 0) {
                // 沒有可移動的棋子
                showStatus("綠方電腦沒有可移動的棋子...");
                setTimeout(nextPlayer, 1000);
                return;
            }
            
            // 選擇最佳移動
            const bestMove = chooseBestMove(availableMoves);
            
            if (bestMove) {
                movePiece('green', bestMove.pieceIndex, gameState.diceValue);
                checkForKnockouts('green', bestMove.pieceIndex);
                
                // 檢查是否贏
                checkWinCondition();
                
                if (gameState.winner) {
                    showWinner(gameState.winner);
                    return;
                }
                
                // 檢查是否需要額外回合
                if (gameState.extraTurn) {
                    gameState.extraTurn = false;
                    showStatus("綠方電腦擊落對手，獲得額外回合！");
                    setTimeout(rollDice, 1500);
                } else {
                    setTimeout(nextPlayer, 1500);
                }
            } else {
                setTimeout(nextPlayer, 1000);
            }
        }, 1000);
    }
    
    // 獲取可用的移動
    function getAvailableMoves(color) {
        const player = gameState.players[color];
        const moves = [];
        
        player.pieces.forEach((position, index) => {
            if (!player.finished[index] && canMovePiece(color, index)) {
                moves.push({
                    pieceIndex: index,
                    position: position,
                    isStarting: !player.started[index]
                });
            }
        });
        
        return moves;
    }
    
    // 選擇最佳移動（簡單AI）
    function chooseBestMove(moves) {
        // 優先選擇可以擊落對手的移動
        for (const move of moves) {
            if (canKnockOpponent('green', move.pieceIndex)) {
                return move;
            }
        }
        
        // 優先選擇已經在路徑上的棋子
        const inPathMoves = moves.filter(move => !move.isStarting);
        if (inPathMoves.length > 0) {
            // 選擇最接近終點的棋子
            return inPathMoves.reduce((best, current) => 
                current.position > best.position ? current : best
            );
        }
        
        // 選擇第一個可以起飛的棋子
        return moves.find(move => move.isStarting) || moves[0];
    }
    
    // 檢查是否可以擊落對手
    function canKnockOpponent(color, pieceIndex) {
        const player = gameState.players[color];
        let newPosition = player.pieces[pieceIndex] + gameState.diceValue;
        
        if (!player.started[pieceIndex] && gameState.diceValue === 6) {
            newPosition = 0;
        }
        
        if (newPosition >= gameState.path.length) return false;
        
        const newPos = gameState.path[newPosition];
        
        // 檢查是否是安全位置
        const isSafe = gameState.safePositions.some(
            safePos => safePos.row === newPos.row && safePos.col === newPos.col
        );
        
        if (isSafe) return false;
        
        // 檢查是否有對手在這個位置
        let hasOpponent = false;
        
        Object.entries(gameState.players).forEach(([otherColor, otherPlayer]) => {
            if (otherColor === color) return;
            
            otherPlayer.pieces.forEach((pos, index) => {
                if (otherPlayer.finished[index] || !otherPlayer.started[index]) return;
                
                if (pos < gameState.path.length) {
                    const otherPos = gameState.path[pos];
                    
                    if (newPos.row === otherPos.row && newPos.col === otherPos.col) {
                        hasOpponent = true;
                    }
                }
            });
        });
        
        return hasOpponent;
    }
    
    // 下一個玩家
    function nextPlayer() {
        const players = ['red', 'yellow', 'blue', 'green'];
        const currentIndex = players.indexOf(gameState.currentPlayer);
        const nextIndex = (currentIndex + 1) % players.length;
        gameState.currentPlayer = players[nextIndex];
        
        // 更新UI
        document.querySelectorAll('.player-info').forEach(el => el.classList.remove('current-player'));
        document.getElementById(`player-${gameState.currentPlayer}`).classList.add('current-player');
        
        gameState.waitingForMove = false;
        gameState.canRoll = true;
        enableRollButton();
        
        // 顯示狀態
        showStatus(`${gameState.playerNames[gameState.currentPlayer]} 的回合`);
        
        // 如果是電腦玩家，自動擲骰子
        if (gameState.currentPlayer === 'green') {
            setTimeout(rollDice, 1000);
        }
    }
    
    // 擲骰子
    function rollDice() {
        if (!gameState.canRoll || gameState.winner) return;
        
        gameState.canRoll = false;
        disableRollButton();
        
        // 動畫效果
        let rollCount = 0;
        const maxRolls = 15;
        const rollInterval = setInterval(() => {
            gameState.diceValue = Math.floor(Math.random() * 6) + 1;
            gameState.diceElement.textContent = gameState.diceValue;
            
            rollCount++;
            if (rollCount >= maxRolls) {
                clearInterval(rollInterval);
                diceRolled();
            }
        }, 100);
    }
    
    // 骰子擲完後
    function diceRolled() {
        showStatus(`${gameState.playerNames[gameState.currentPlayer]} 擲出了 ${gameState.diceValue}！`);
        
        const availableMoves = getAvailableMoves(gameState.currentPlayer);
        
        if (availableMoves.length === 0) {
            // 沒有可移動的棋子
            showStatus("沒有可移動的棋子，跳過回合...");
            setTimeout(nextPlayer, 1500);
            return;
        }
        
        gameState.waitingForMove = true;
        
        if (gameState.currentPlayer === 'green') {
            computerMove();
        }
    }
    
    // 跳過回合
    function skipTurn() {
        if (!gameState.waitingForMove || gameState.winner) return;
        
        showStatus(`${gameState.playerNames[gameState.currentPlayer]} 跳過了回合`);
        setTimeout(nextPlayer, 1000);
    }
    
    // 更新狀態顯示
    function updateStatus() {
        // 更新每個玩家的狀態
        Object.keys(gameState.players).forEach(color => {
            const player = gameState.players[color];
            const readyCount = player.started.filter(started => started).length;
            const finishedCount = player.finished.filter(finished => finished).length;
            
            document.getElementById(`ready-${color}`).textContent = `${readyCount}/4`;
            document.getElementById(`finished-${color}`).textContent = `${finishedCount}/4`;
        });
    }
    
    // 顯示狀態消息
    function showStatus(message) {
        gameState.statusElement.textContent = message;
    }
    
    // 顯示贏家
    function showWinner(winnerColor) {
        const winnerName = gameState.playerNames[winnerColor];
        
        // 創建獲勝畫面
        const winnerScreen = document.createElement('div');
        winnerScreen.className = 'winner-message';
        winnerScreen.innerHTML = `
            <h2 class="winner-title">${winnerName} 勝利！</h2>
            <div class="winner-color" style="background: ${getWinnerColor(winnerColor)};"></div>
            <button class="btn btn-roll" id="restart-btn">再玩一次</button>
        `;
        
        document.body.appendChild(winnerScreen);
        
        // 添加重啟按鈕事件
        document.getElementById('restart-btn').addEventListener('click', restartGame);
        
        // 創建彩色紙屑
        createConfetti();
    }
    
    // 獲取贏家顏色
    function getWinnerColor(color) {
        const colors = {
            red: '#ff5252',
            yellow: '#ffd700',
            blue: '#4da6ff',
            green: '#4dff88'
        };
        return colors[color];
    }
    
    // 創建彩色紙屑
    function createConfetti() {
        const colors = ['#ff5252', '#ffd700', '#4da6ff', '#4dff88', '#ff4081', '#7c4dff'];
        const confettiCount = 150;
        
        for (let i = 0; i < confettiCount; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.left = `${Math.random() * 100}%`;
            confetti.style.top = `-${Math.random() * 20}%`;
            confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
            confetti.style.opacity = Math.random();
            document.body.appendChild(confetti);
            
            // 移除動畫完成後的紙屑
            setTimeout(() => {
                if (confetti.parentNode) {
                    confetti.parentNode.removeChild(confetti);
                }
            }, 5000);
        }
    }
    
    // 重啟遊戲
    function restartGame() {
        // 重置遊戲狀態
        gameState.currentPlayer = 'red';
        gameState.diceValue = 0;
        gameState.canRoll = true;
        gameState.extraTurn = false;
        gameState.waitingForMove = false;
        gameState.winner = null;
        
        // 重置玩家狀態
        Object.keys(gameState.players).forEach(color => {
            gameState.players[color] = { 
                pieces: [0, 0, 0, 0], 
                started: [false, false, false, false], 
                finished: [false, false, false, false] 
            };
        });
        
        // 移除獲勝畫面
        const winnerScreen = document.querySelector('.winner-message');
        if (winnerScreen) {
            winnerScreen.remove();
        }
        
        // 移除所有紙屑
        document.querySelectorAll('.confetti').forEach(confetti => confetti.remove());
        
        // 重新渲染
        renderPieces();
        
        // 更新UI
        document.querySelectorAll('.player-info').forEach(el => el.classList.remove('current-player'));
        document.getElementById('player-red').classList.add('current-player');
        
        gameState.diceElement.textContent = '?';
        enableRollButton();
        gameState.skipButton.disabled = true;
        
        showStatus('紅方玩家，請擲骰子開始遊戲！');
    }
    
    // 禁用擲骰子按鈕
    function disableRollButton() {
        gameState.rollButton.disabled = true;
        gameState.rollButton.style.opacity = '0.6';
        gameState.rollButton.style.transform = 'none';
        gameState.rollButton.style.boxShadow = 'none';
    }
    
    // 啟用擲骰子按鈕
    function enableRollButton() {
        gameState.rollButton.disabled = false;
        gameState.rollButton.style.opacity = '1';
    }
    
    // 設置事件監聽
    function setupEventListeners() {
        gameState.rollButton.addEventListener('click', rollDice);
        gameState.skipButton.addEventListener('click', skipTurn);
    }
    
    // 初始化遊戲
    document.addEventListener('DOMContentLoaded', initGame);
</script>