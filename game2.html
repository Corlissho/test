<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>æ¥µé€ŸF1è³½é“ - ç¬¬ä¸€è¦–è§’å°„æ“Š</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: 'Arial', sans-serif;
background: linear-gradient(to bottom, #1a1a2e, #16213e);
color: #fff;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
min-height: 100vh;
padding: 20px;
position: relative;
}
.container {
max-width: 900px;
width: 100%;
text-align: center;
}
header {
margin-bottom: 20px;
}
h1 {
font-size: 2.8rem;
margin-bottom: 10px;
background: linear-gradient(to right, #FFD700, #FFA500);
background-clip: text;
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
letter-spacing: 2px;
}
.subtitle {
font-size: 1.2rem;
color: #aaa;
margin-bottom: 20px;
}
.game-container {
position: relative;
margin: 0 auto 30px;
overflow: hidden;
border-radius: 10px;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
}
#gameCanvas {
background-color: #0f3460;
display: block;
width: 100%;
}
.top-controls {
position: absolute;
top: 20px;
right: 20px;
z-index: 100;
display: flex;
gap: 10px;
}
.top-controls button {
background: linear-gradient(to right, #FF416C, #FF4B2B);
background-clip: border-box;
-webkit-background-clip: border-box;
border: none;
border-radius: 50px;
color: white;
padding: 10px 20px;
font-size: 1rem;
font-weight: bold;
cursor: pointer;
transition: all 0.3s;
box-shadow: 0 5px 15px rgba(255, 65, 108, 0.4);
}
.top-controls button:hover {
transform: translateY(-3px);
box-shadow: 0 8px 20px rgba(255, 65, 108, 0.6);
}
.top-controls button:active {
transform: translateY(1px);
}
.controls {
display: flex;
justify-content: space-between;
width: 100%;
max-width: 800px;
margin-bottom: 30px;
}
.control-panel {
background: rgba(255, 255, 255, 0.1);
border-radius: 10px;
padding: 20px;
flex: 1;
margin: 0 10px;
}
.control-panel h2 {
color: #4FC3F7;
margin-bottom: 15px;
font-size: 1.5rem;
}
.key-controls {
display: grid;
grid-template-columns: repeat(3, 1fr);
grid-template-rows: repeat(3, 1fr);
gap: 10px;
max-width: 200px;
margin: 0 auto;
}
.key {
background: rgba(0, 0, 0, 0.5);
border: 2px solid #4FC3F7;
border-radius: 8px;
padding: 15px;
font-size: 1.5rem;
font-weight: bold;
display: flex;
align-items: center;
justify-content: center;
color: white;
user-select: none;
transition: all 0.1s;
}
.key.active {
background: #4FC3F7;
transform: scale(0.95);
box-shadow: 0 0 15px #4FC3F7;
}
.key-up {
grid-column: 2;
grid-row: 1;
}
.key-left {
grid-column: 1;
grid-row: 2;
}
.key-down {
grid-column: 2;
grid-row: 2;
}
.key-right {
grid-column: 3;
grid-row: 2;
}
.game-info {
display: flex;
justify-content: space-around;
margin-top: 20px;
flex-wrap: wrap;
}
.info-box {
background: rgba(255, 255, 255, 0.1);
border-radius: 10px;
padding: 15px 25px;
min-width: 150px;
margin: 10px;
}
.info-title {
color: #FFD700;
font-size: 1rem;
margin-bottom: 5px;
}
.info-value {
font-size: 2rem;
font-weight: bold;
color: white;
}
.race-progress {
background: rgba(255, 255, 255, 0.1);
border-radius: 10px;
padding: 15px;
margin-top: 10px;
}
.progress-bar {
height: 20px;
background: rgba(0, 0, 0, 0.5);
border-radius: 10px;
overflow: hidden;
margin-top: 8px;
position: relative;
}
.progress-fill {
height: 100%;
background: linear-gradient(to right, #4FC3F7, #FFD700);
border-radius: 10px;
width: 0%;
transition: width 0.3s;
}
.mini-map-container {
position: absolute;
bottom: 20px;
right: 20px;
background: rgba(0, 0, 0, 0.7);
border-radius: 10px;
padding: 10px;
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
z-index: 50;
}
#miniMap {
width: 150px;
height: 150px;
display: block;
}
.instructions {
background: rgba(255, 255, 255, 0.1);
border-radius: 10px;
padding: 20px;
margin-top: 30px;
text-align: left;
max-width: 800px;
}
.instructions h2 {
color: #4FC3F7;
margin-bottom: 15px;
text-align: center;
}
.instructions ul {
padding-left: 20px;
margin-bottom: 15px;
}
.instructions li {
margin-bottom: 8px;
line-height: 1.5;
}
.instructions p {
color: #aaa;
font-style: italic;
text-align: center;
}
.game-over {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.85);
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
z-index: 10;
display: none;
}
.game-over h2 {
font-size: 3.5rem;
color: #FF416C;
margin-bottom: 20px;
}
.game-over p {
font-size: 1.5rem;
margin-bottom: 30px;
}
.status-effects {
display: flex;
justify-content: center;
gap: 15px;
margin-top: 10px;
flex-wrap: wrap;
}
.status-effect {
background: rgba(255, 255, 255, 0.15);
border-radius: 8px;
padding: 8px 15px;
font-size: 0.9rem;
display: flex;
align-items: center;
gap: 8px;
}
.status-effect-icon {
width: 20px;
height: 20px;
border-radius: 50%;
}
.shield-icon { background-color: #4CAF50; }
.slow-icon { background-color: #FFC107; }
.double-icon { background-color: #9C27B0; }
.magnet-icon { background-color: #2196F3; }
.speed-icon { background-color: #FFD700; }
@media (max-width: 768px) {
.controls {
flex-direction: column;
}
.control-panel {
margin: 10px 0;
}
.game-info {
flex-direction: column;
align-items: center;
}
.status-effects {
flex-direction: column;
align-items: center;
}
.top-controls {
position: static;
margin-bottom: 15px;
flex-wrap: wrap;
}
.mini-map-container {
position: static;
margin-top: 15px;
}
}
</style>
</head>
<body>
<div class="container">
<header>
<h1>æ¥µé€ŸF1è³½é“</h1>
<p class="subtitle">ä½¿ç”¨æ–¹å‘éµæ§åˆ¶è·‘è»Šï¼Œå¾æœå½æ›²è³½é“ï¼Œçˆ­å–æœ€å¿«åœˆé€Ÿï¼</p>
</header>
<div class="game-container">
<canvas id="gameCanvas" width="800" height="600"></canvas>
<div class="mini-map-container">
<canvas id="miniMap" width="150" height="150"></canvas>
<div style="text-align: center; margin-top: 5px; font-size: 0.8rem; color: #FFD700;">è³½é“åœ°åœ–</div>
</div>
<div class="top-controls">
<button id="startButton">é–‹å§‹éŠæˆ²</button>
<button id="pauseButton">æš«åœéŠæˆ²</button>
</div>
<div class="game-over" id="gameOverScreen">
<h2>éŠæˆ²çµæŸï¼</h2>
<p>ä½ çš„åˆ†æ•¸ï¼š<span id="finalScore">0</span></p>
<button id="restartButton">é‡æ–°é–‹å§‹</button>
</div>
</div>
<div class="controls">
<div class="control-panel">
<h2>æ§åˆ¶éµ</h2>
<div class="key-controls">
<div class="key key-up" id="keyUp">â†‘</div>
<div class="key key-left" id="keyLeft">â†</div>
<div class="key key-down" id="keyDown">â†“</div>
<div class="key key-right" id="keyRight">â†’</div>
</div>
</div>
<div class="control-panel">
<h2>éŠæˆ²ç‹€æ…‹</h2>
<div class="game-info">
<div class="info-box">
<div class="info-title">åˆ†æ•¸</div>
<div class="info-value" id="score">0</div>
</div>
<div class="info-box">
<div class="info-title">é€Ÿåº¦</div>
<div class="info-value" id="speed">0 km/h</div>
</div>
<div class="info-box">
<div class="info-title">ç”Ÿå‘½å€¼</div>
<div class="info-value" id="lives">3</div>
</div>
</div>
<div class="race-progress">
<div class="info-title">è³½é“é€²åº¦</div>
<div class="progress-bar">
<div class="progress-fill" id="progressFill"></div>
</div>
<div style="text-align: right; font-size: 0.9rem; margin-top: 5px; color: #FFD700;">
<span id="lapProgress">0</span>% / 100%
</div>
</div>
<div class="status-effects" id="statusEffects">
<!-- ç‹€æ…‹æ•ˆæœå°‡åœ¨é€™è£¡å‹•æ…‹ç”Ÿæˆ -->
</div>
</div>
</div>
<div class="instructions">
<h2>éŠæˆ²èªªæ˜</h2>
<ul>
<li>ä½¿ç”¨ <strong>â†‘ ä¸‹éµ</strong> åŠ é€Ÿ/æ¸›é€Ÿ</li>
<li>ä½¿ç”¨ <strong>â† â†’ éµ</strong> å·¦å³è½‰å‘æ§åˆ¶æ–¹å‘</li>
<li>åœ¨å½é“è™•æå‰æ¸›é€Ÿï¼Œé¿å…è¡å‡ºè³½é“</li>
<li>ä¿æŒåœ¨è³½é“ä¸Šä»¥ç²å¾—æŒçºŒåŠ åˆ†</li>
<li><strong>æ–°é“å…·ç³»çµ±ï¼š</strong></li>
<li style="margin-left: 20px;">ğŸŸ¢ <strong>è­·ç›¾</strong>ï¼šç¶ è‰²åœ“åœˆï¼Œ3ç§’ç„¡æ•µ</li>
<li style="margin-left: 20px;">ğŸŸ¡ <strong>æ¸›é€Ÿ</strong>ï¼šé»ƒè‰²åœ“åœˆï¼Œ5ç§’å…§æ‰€æœ‰æ•µè»Šæ¸›é€Ÿ</li>
<li style="margin-left: 20px;">ğŸŸ£ <strong>åˆ†æ•¸åŠ å€</strong>ï¼šç´«è‰²æ˜Ÿæ˜Ÿï¼Œ30ç§’å…§åˆ†æ•¸åŠ å€</li>
<li style="margin-left: 20px;">ğŸ”µ <strong>ç£éµ</strong>ï¼šè—è‰²ç£éµï¼Œè‡ªå‹•å¸å¼•é™„è¿‘é“å…·</li>
<li style="margin-left: 20px;">ğŸŸ¡ <strong>åŠ é€Ÿ</strong>ï¼šé»ƒè‰²é–ƒé›»ï¼Œ3ç§’å…§é€Ÿåº¦æå‡</li>
<li>å®Œæˆä¸€åœˆè³½é“å¯ç²å¾—çå‹µåˆ†æ•¸</li>
<li>éŠæˆ²ç›®æ¨™ï¼šåœ¨ä¸€åœˆå…§ç²å¾—æœ€é«˜åˆ†ï¼</li>
</ul>
<p>æ³¨æ„ï¼šè»Šé€Ÿè¶Šå¿«ï¼Œè½‰å½è¶Šå›°é›£ï¼</p>
</div>
</div>
<script>
// éŠæˆ²è®Šæ•¸
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const miniMapCanvas = document.getElementById('miniMap');
const miniMapCtx = miniMapCanvas.getContext('2d');
const scoreElement = document.getElementById('score');
const speedElement = document.getElementById('speed');
const livesElement = document.getElementById('lives');
const startButton = document.getElementById('startButton');
const pauseButton = document.getElementById('pauseButton');
const restartButton = document.getElementById('restartButton');
const gameOverScreen = document.getElementById('gameOverScreen');
const finalScoreElement = document.getElementById('finalScore');
const statusEffectsElement = document.getElementById('statusEffects');
const progressFillElement = document.getElementById('progressFill');
const lapProgressElement = document.getElementById('lapProgress');
// æ§åˆ¶éµå…ƒç´ 
const keyUp = document.getElementById('keyUp');
const keyDown = document.getElementById('keyDown');
const keyLeft = document.getElementById('keyLeft');
const keyRight = document.getElementById('keyRight');
// éŠæˆ²ç‹€æ…‹
let gameRunning = false;
let gamePaused = false;
let score = 0;
let lives = 3;
let speed = 0;
let trackProgress = 0; // è³½é“é€²åº¦ (0-100%)
const totalTrackLength = 3000; // ç¸½è³½é“é•·åº¦ï¼ˆå–®ä½ï¼‰
let currentLap = 0;
let maxSpeed = 15;
let acceleration = 0.2;
let deceleration = 0.1;
// å®šç¾©F1è³½é“æ§åˆ¶é»
const trackPoints = [
{ x: canvas.width / 2, y: -100 },       // èµ·é»
{ x: canvas.width / 2, y: 100 },        // ç›´é“
{ x: canvas.width / 2 + 150, y: 300 },  // ç¬¬ä¸€å€‹å³å½
{ x: canvas.width / 2 + 300, y: 400 },  // å½å¿ƒ
{ x: canvas.width / 2 + 200, y: 550 },  // å½é“å‡ºå£
{ x: canvas.width / 2, y: 700 },        // ç›´é“
{ x: canvas.width / 2 - 200, y: 900 },  // å·¦å½
{ x: canvas.width / 2 - 300, y: 1000 }, // å½å¿ƒ
{ x: canvas.width / 2 - 150, y: 1150 }, // å½é“å‡ºå£
{ x: canvas.width / 2, y: 1300 },       // ç›´é“
{ x: canvas.width / 2 + 100, y: 1500 }, // å³å½
{ x: canvas.width / 2, y: 1700 },       // çµ‚é»ç›´é“
];
// è¨ˆç®—è³½é“ç¸½é•·åº¦
function calculateTrackLength() {
let length = 0;
for (let i = 1; i < trackPoints.length; i++) {
const dx = trackPoints[i].x - trackPoints[i-1].x;
const dy = trackPoints[i].y - trackPoints[i-1].y;
length += Math.sqrt(dx * dx + dy * dy);
}
return length;
}
const actualTrackLength = calculateTrackLength();
// é“å…·é¡å‹å®šç¾©
const POWERUP_TYPES = {
SHIELD: {
id: 'shield',
name: 'è­·ç›¾',
color: '#4CAF50',
duration: 3000,
icon: 'ğŸ›¡ï¸',
drawFunction: drawShieldPowerUp
},
SLOW_ENEMY: {
id: 'slow',
name: 'æ¸›é€Ÿ',
color: '#FFC107',
duration: 5000,
icon: 'ğŸ¢',
drawFunction: drawSlowPowerUp
},
DOUBLE_SCORE: {
id: 'double',
name: 'åˆ†æ•¸åŠ å€',
color: '#9C27B0',
duration: 30000,
icon: 'â­',
drawFunction: drawDoubleScorePowerUp
},
MAGNET: {
id: 'magnet',
name: 'ç£éµ',
color: '#2196F3',
duration: 10000,
icon: 'ğŸ§²',
drawFunction: drawMagnetPowerUp
},
SPEED_BOOST: {
id: 'speed',
name: 'åŠ é€Ÿ',
color: '#FFD700',
duration: 3000,
icon: 'âš¡',
drawFunction: drawSpeedPowerUp
}
};
// ç©å®¶ç‹€æ…‹æ•ˆæœ
let playerEffects = {
shield: { active: false, endTime: 0 },
slowEnemy: { active: false, endTime: 0 },
doubleScore: { active: false, endTime: 0 },
magnet: { active: false, endTime: 0, range: 200 },
speedBoost: { active: false, endTime: 0 }
};
// ç©å®¶è»Šè¼›
const playerCar = {
x: canvas.width / 2,
y: canvas.height - 150,
width: 40,
height: 70,
color: '#FF416C',
angle: 0, // è»Šè¼›è§’åº¦ï¼ˆç”¨æ–¼è½‰å‘ï¼‰
speed: 0,
maxSpeed: maxSpeed,
acceleration: acceleration,
deceleration: deceleration,
steering: 0, // è½‰å‘è§’åº¦
steeringSpeed: 0.05, // è½‰å‘é€Ÿåº¦
isInvulnerable: false,
trackPosition: 0 // è»Šè¼›åœ¨è³½é“ä¸Šçš„ä½ç½® (0-1)
};
// æ•µæ–¹è»Šè¼›é™£åˆ—
let enemyCars = [];
// é“å…·é™£åˆ—
let powerUps = [];
// æ§åˆ¶ç‹€æ…‹
const keys = {
ArrowUp: false,
ArrowDown: false,
ArrowLeft: false,
ArrowRight: false
};
// è³½é“å¯¬åº¦
const trackWidth = 200;
// è½‰å½ä¿‚æ•¸ï¼ˆç”¨æ–¼æ¨¡æ“¬è½‰å½æ™‚çš„é›¢å¿ƒåŠ›ï¼‰
const turnFactor = 0.5;

// åˆå§‹åŒ–éŠæˆ²
function initGame() {
score = 0;
lives = 3;
speed = 0;
trackProgress = 0;
currentLap = 0;
playerCar.x = canvas.width / 2;
playerCar.y = canvas.height - 150;
playerCar.angle = 0;
playerCar.speed = 0;
playerCar.trackPosition = 0;
playerCar.isInvulnerable = false;
enemyCars = [];
powerUps = [];
// é‡ç½®æ‰€æœ‰æ•ˆæœ
for (let effect in playerEffects) {
playerEffects[effect].active = false;
playerEffects[effect].endTime = 0;
}
gameOverScreen.style.display = 'none';
updateUI();
updateStatusEffects();
}

// ç²å–è³½é“ä¸ŠæŸå€‹ä½ç½®çš„é»
function getTrackPoint(position) {
// position: 0-1 ä¹‹é–“çš„å€¼ï¼Œè¡¨ç¤ºè³½é“ä¸Šçš„ç›¸å°ä½ç½®
const totalPoints = trackPoints.length - 1;
const segment = Math.floor(position * totalPoints);
const t = (position * totalPoints) - segment;
const p0 = trackPoints[segment];
const p1 = trackPoints[segment + 1];
return {
x: p0.x + (p1.x - p0.x) * t,
y: p0.y + (p1.y - p0.y) * t
};
}

// ç²å–è³½é“ä¸ŠæŸå€‹ä½ç½®çš„æ–¹å‘ï¼ˆç”¨æ–¼è½‰å‘ï¼‰
function getTrackDirection(position) {
const delta = 0.01;
const p0 = getTrackPoint(position);
const p1 = getTrackPoint(position + delta);
return Math.atan2(p1.y - p0.y, p1.x - p0.x);
}

// ç¹ªè£½å½æ›²è³½é“
function drawTrack(offsetY) {
// æ¸…é™¤èƒŒæ™¯
ctx.fillStyle = '#0f3460';
ctx.fillRect(0, 0, canvas.width, canvas.height);
// ç¹ªè£½èƒŒæ™¯å…ƒç´ 
drawBackground();
// è¨ˆç®—éœ€è¦ç¹ªè£½çš„è³½é“é»
const points = [];
const leftPoints = [];
const rightPoints = [];
const resolution = 150; // è³½é“ç´°åˆ†åº¦
for (let i = 0; i <= resolution; i++) {
const t = i / resolution;
const point = getTrackPoint(t);
const direction = getTrackDirection(t);
// è¨ˆç®—è³½é“å·¦å³é‚Šç•Œ
const perpendicularAngle = direction + Math.PI/2;
const leftX = point.x + Math.cos(perpendicularAngle) * trackWidth/2;
const leftY = point.y + Math.sin(perpendicularAngle) * trackWidth/2;
const rightX = point.x - Math.cos(perpendicularAngle) * trackWidth/2;
const rightY = point.y - Math.sin(perpendicularAngle) * trackWidth/2;
// æ‡‰ç”¨å‚ç›´åç§»ï¼ˆæ»¾å‹•æ•ˆæœï¼‰
const visibleY = point.y - offsetY;
const visibleLeftY = leftY - offsetY;
const visibleRightY = rightY - offsetY;
points.push({x: point.x, y: visibleY});
leftPoints.push({x: leftX, y: visibleLeftY});
rightPoints.push({x: rightX, y: visibleRightY});
}
// ç¹ªè£½è³½é“è·¯é¢
ctx.beginPath();
ctx.moveTo(leftPoints[0].x, leftPoints[0].y);
for (let i = 1; i < leftPoints.length; i++) {
ctx.lineTo(leftPoints[i].x, leftPoints[i].y);
}
for (let i = rightPoints.length - 1; i >= 0; i--) {
ctx.lineTo(rightPoints[i].x, rightPoints[i].y);
}
ctx.closePath();
ctx.fillStyle = '#333';
ctx.fill();
// ç¹ªè£½è³½é“é‚Šç·š
ctx.beginPath();
for (let i = 0; i < leftPoints.length; i++) {
if (i === 0) ctx.moveTo(leftPoints[i].x, leftPoints[i].y);
else ctx.lineTo(leftPoints[i].x, leftPoints[i].y);
}
ctx.strokeStyle = '#FF0000';
ctx.lineWidth = 3;
ctx.stroke();
ctx.beginPath();
for (let i = 0; i < rightPoints.length; i++) {
if (i === 0) ctx.moveTo(rightPoints[i].x, rightPoints[i].y);
else ctx.lineTo(rightPoints[i].x, rightPoints[i].y);
}
ctx.strokeStyle = '#FF0000';
ctx.lineWidth = 3;
ctx.stroke();
// ç¹ªè£½ä¸­ç·šæ¨™è¨˜
ctx.setLineDash([20, 20]); // è™›ç·š
ctx.beginPath();
for (let i = 0; i < points.length; i++) {
if (i === 0) ctx.moveTo(points[i].x, points[i].y);
else ctx.lineTo(points[i].x, points[i].y);
}
ctx.strokeStyle = '#FFFFFF';
ctx.lineWidth = 2;
ctx.stroke();
ctx.setLineDash([]); // é‡ç½®è™›ç·š
// ç¹ªè£½èµ·çµ‚é»ç·š
drawStartFinishLine(offsetY);
// ç¹ªè£½å½é“æç¤ºæ¨™èªŒ
drawCurveMarkers(offsetY);
}

// ç¹ªè£½èµ·çµ‚é»ç·š
function drawStartFinishLine(offsetY) {
const startPoint = getTrackPoint(0);
const finishPoint = getTrackPoint(1);
const direction = getTrackDirection(1);
const perpendicularAngle = direction + Math.PI/2;
const leftX = finishPoint.x + Math.cos(perpendicularAngle) * trackWidth/2;
const leftY = finishPoint.y + Math.sin(perpendicularAngle) * trackWidth/2;
const rightX = finishPoint.x - Math.cos(perpendicularAngle) * trackWidth/2;
const rightY = finishPoint.y - Math.sin(perpendicularAngle) * trackWidth/2;
// èµ·çµ‚é»ç·š
ctx.beginPath();
ctx.moveTo(leftX, leftY - offsetY);
ctx.lineTo(rightX, rightY - offsetY);
ctx.strokeStyle = '#FFFFFF';
ctx.lineWidth = 6;
ctx.stroke();
// æ£‹ç›¤æ ¼ç´‹ç†
ctx.fillStyle = '#FFFFFF';
for (let i = 0; i < 10; i++) {
for (let j = 0; j < 4; j++) {
const x = leftX + (rightX - leftX) * (i/10);
const y = leftY - offsetY + (rightY - leftY) * (j/4);
if ((i + j) % 2 === 0) {
ctx.fillRect(x - 5, y - 5, 10, 10);
}
}
}
}

// ç¹ªè£½å½é“æç¤ºæ¨™èªŒ
function drawCurveMarkers(offsetY) {
// åœ¨å½é“è™•ç¹ªè£½æç¤ºæ¨™èªŒ
const curvePoints = [
{ position: 0.15, type: 'right', marker: 'â®' },  // ç¬¬ä¸€å€‹å³å½
{ position: 0.45, type: 'left', marker: 'â®Ÿ' },   // å·¦å½
{ position: 0.75, type: 'right', marker: 'â®' }   // å³å½
];
curvePoints.forEach(point => {
const trackPoint = getTrackPoint(point.position);
const direction = getTrackDirection(point.position);
// è¨ˆç®—æ¨™èªŒä½ç½®ï¼ˆåœ¨è³½é“ä¸Šæ–¹ï¼‰
const markerX = trackPoint.x;
const markerY = trackPoint.y - offsetY - 50;
// ç¹ªè£½æ¨™èªŒ
ctx.font = '24px Arial';
ctx.fillStyle = '#FFD700';
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(point.marker, markerX, markerY);
// ç¹ªè£½ç®­é ­æŒ‡å‘å½é“
ctx.beginPath();
ctx.moveTo(markerX, markerY + 20);
ctx.lineTo(trackPoint.x, trackPoint.y - offsetY);
ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
ctx.lineWidth = 2;
ctx.stroke();
});
}

// ç¹ªè£½èƒŒæ™¯
function drawBackground() {
// é è™•å±±è„ˆ
ctx.fillStyle = 'rgba(15, 52, 96, 0.7)';
ctx.beginPath();
ctx.moveTo(0, 100);
ctx.lineTo(150, 50);
ctx.lineTo(300, 120);
ctx.lineTo(500, 80);
ctx.lineTo(700, 130);
ctx.lineTo(800, 90);
ctx.lineTo(800, 0);
ctx.lineTo(0, 0);
ctx.closePath();
ctx.fill();
// é›²æœµ
ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
drawCloud(100, 60, 40);
drawCloud(400, 40, 30);
drawCloud(600, 80, 50);
}

// ç¹ªè£½é›²æœµ
function drawCloud(x, y, size) {
ctx.beginPath();
ctx.arc(x, y, size, 0, Math.PI * 2);
ctx.arc(x + size * 0.8, y - size * 0.3, size * 0.7, 0, Math.PI * 2);
ctx.arc(x + size * 1.5, y, size * 0.8, 0, Math.PI * 2);
ctx.arc(x + size * 0.8, y + size * 0.3, size * 0.7, 0, Math.PI * 2);
ctx.fill();
}

// ç¹ªè£½ç©å®¶è»Šè¼›ï¼ˆæ—‹è½‰ç‰ˆï¼‰
function drawPlayerCar() {
ctx.save();
// å°‡åŸé»ç§»åˆ°è»Šè¼›ä¸­å¿ƒ
ctx.translate(playerCar.x, playerCar.y);
// æ—‹è½‰ç•«å¸ƒ
ctx.rotate(playerCar.angle);
// å¦‚æœæœ‰è­·ç›¾æ•ˆæœï¼Œç¹ªè£½è­·ç›¾
if (playerEffects.shield.active) {
ctx.strokeStyle = '#4CAF50';
ctx.lineWidth = 3;
ctx.beginPath();
ctx.arc(0, 0, Math.max(playerCar.width, playerCar.height)/2 + 15, 0, Math.PI * 2);
ctx.stroke();
// è­·ç›¾è„ˆè¡æ•ˆæœ
const pulse = (Date.now() % 1000) / 1000;
ctx.globalAlpha = 0.3 + 0.2 * Math.sin(pulse * Math.PI * 2);
ctx.fillStyle = '#4CAF50';
ctx.beginPath();
ctx.arc(0, 0, Math.max(playerCar.width, playerCar.height)/2 + 10, 0, Math.PI * 2);
ctx.fill();
ctx.globalAlpha = 1.0;
}
// è»Šèº«
ctx.fillStyle = playerCar.color;
ctx.fillRect(-playerCar.width/2, -playerCar.height/2, playerCar.width, playerCar.height);
// è»Šçª—
ctx.fillStyle = '#4FC3F7';
ctx.fillRect(-playerCar.width/2 + 5, -playerCar.height/2 + 10, playerCar.width - 10, playerCar.height/3);
// è»Šç‡ˆ
ctx.fillStyle = '#FFD700';
ctx.fillRect(-playerCar.width/2 + 5, playerCar.height/2 - 15, 10, 10);
ctx.fillRect(playerCar.width/2 - 15, playerCar.height/2 - 15, 10, 10);
// è¼ªèƒ
ctx.fillStyle = '#222';
ctx.fillRect(-playerCar.width/2 - 5, -playerCar.height/2 + 15, 5, 25);
ctx.fillRect(playerCar.width/2, -playerCar.height/2 + 15, 5, 25);
ctx.fillRect(-playerCar.width/2 - 5, playerCar.height/2 - 40, 5, 25);
ctx.fillRect(playerCar.width/2, playerCar.height/2 - 40, 5, 25);
// è»Šé ‚
ctx.fillStyle = '#333';
ctx.fillRect(-playerCar.width/2 + 8, -playerCar.height/2 - 5, playerCar.width - 16, 10);
ctx.restore();
// å¦‚æœæœ‰ç£éµæ•ˆæœï¼Œç¹ªè£½ç£åŠ›ç¯„åœ
if (playerEffects.magnet.active) {
ctx.strokeStyle = '#2196F3';
ctx.lineWidth = 2;
ctx.setLineDash([5, 5]);
ctx.beginPath();
ctx.arc(
playerCar.x,
playerCar.y,
playerEffects.magnet.range,
0, Math.PI * 2
);
ctx.stroke();
ctx.setLineDash([]);
}
}

// ç¹ªè£½æ•µæ–¹è»Šè¼›
function drawEnemyCars(offsetY) {
enemyCars.forEach(car => {
ctx.save();
ctx.translate(car.x, car.y - offsetY);
ctx.rotate(car.angle);
// å¦‚æœæœ‰æ¸›é€Ÿæ•ˆæœï¼Œæ”¹è®Šè»Šè¼›é¡è‰²
if (playerEffects.slowEnemy.active) {
ctx.fillStyle = '#666'; // è®Šç°è¡¨ç¤ºæ¸›é€Ÿ
} else {
ctx.fillStyle = car.color;
}
ctx.fillRect(-car.width/2, -car.height/2, car.width, car.height);
// è»Šçª—
ctx.fillStyle = '#999';
ctx.fillRect(-car.width/2 + 5, -car.height/2 + 10, car.width - 10, car.height/3);
// è¼ªèƒ
ctx.fillStyle = '#222';
ctx.fillRect(-car.width/2 - 5, -car.height/2 + 15, 5, 20);
ctx.fillRect(car.width/2, -car.height/2 + 15, 5, 20);
ctx.fillRect(-car.width/2 - 5, car.height/2 - 35, 5, 20);
ctx.fillRect(car.width/2, car.height/2 - 35, 5, 20);
ctx.restore();
});
}

// ç¹ªè£½è­·ç›¾é“å…·
function drawShieldPowerUp(x, y, size) {
// å¤–åœˆ
ctx.strokeStyle = '#4CAF50';
ctx.lineWidth = 3;
ctx.beginPath();
ctx.arc(x, y, size/2, 0, Math.PI * 2);
ctx.stroke();
// å…§åœˆ
ctx.fillStyle = '#4CAF50';
ctx.beginPath();
ctx.arc(x, y, size/3, 0, Math.PI * 2);
ctx.fill();
// è­·ç›¾åœ–æ¨™
ctx.fillStyle = '#FFFFFF';
ctx.beginPath();
// ç¹ªè£½ç°¡å–®çš„ç›¾ç‰Œå½¢ç‹€
ctx.moveTo(x, y - size/4);
ctx.lineTo(x - size/4, y);
ctx.lineTo(x, y + size/4);
ctx.lineTo(x + size/4, y);
ctx.closePath();
ctx.fill();
}

// ç¹ªè£½æ¸›é€Ÿé“å…·
function drawSlowPowerUp(x, y, size) {
// é»ƒè‰²åœ“åœˆ
ctx.fillStyle = '#FFC107';
ctx.beginPath();
ctx.arc(x, y, size/2, 0, Math.PI * 2);
ctx.fill();
// çƒé¾œåœ–æ¨™
ctx.fillStyle = '#795548';
// çƒé¾œèº«é«”
ctx.beginPath();
ctx.ellipse(x, y, size/3, size/4, 0, 0, Math.PI * 2);
ctx.fill();
// çƒé¾œé ­
ctx.beginPath();
ctx.arc(x, y - size/6, size/8, 0, Math.PI * 2);
ctx.fill();
}

// ç¹ªè£½åˆ†æ•¸åŠ å€é“å…·
function drawDoubleScorePowerUp(x, y, size) {
// ç´«è‰²æ˜Ÿæ˜ŸèƒŒæ™¯
ctx.fillStyle = '#9C27B0';
ctx.beginPath();
ctx.arc(x, y, size/2, 0, Math.PI * 2);
ctx.fill();
// æ˜Ÿæ˜Ÿ
ctx.fillStyle = '#FFFFFF';
drawStar(ctx, x, y, 5, size/4, size/8);
}

// ç¹ªè£½ç£éµé“å…·
function drawMagnetPowerUp(x, y, size) {
// è—è‰²èƒŒæ™¯
ctx.fillStyle = '#2196F3';
ctx.beginPath();
ctx.arc(x, y, size/2, 0, Math.PI * 2);
ctx.fill();
// ç£éµåœ–æ¨™
ctx.fillStyle = '#FFFFFF';
// ç£éµçš„Uå½¢
ctx.beginPath();
ctx.arc(x, y, size/3, Math.PI * 0.25, Math.PI * 0.75);
ctx.arc(x, y, size/3, Math.PI * 1.25, Math.PI * 1.75);
ctx.closePath();
ctx.fill();
}

// ç¹ªè£½åŠ é€Ÿé“å…·
function drawSpeedPowerUp(x, y, size) {
// é“å…·å¤–æ¡†
ctx.fillStyle = '#4FC3F7';
ctx.beginPath();
ctx.arc(x, y, size/2 + 2, 0, Math.PI * 2);
ctx.fill();
// é“å…·å…§éƒ¨
ctx.fillStyle = '#FFD700';
ctx.beginPath();
ctx.arc(x, y, size/2 - 2, 0, Math.PI * 2);
ctx.fill();
// é–ƒé›»åœ–æ¨™
ctx.fillStyle = '#4FC3F7';
ctx.beginPath();
ctx.moveTo(x, y - size/3);
ctx.lineTo(x - size/6, y);
ctx.lineTo(x, y);
ctx.lineTo(x + size/6, y + size/6);
ctx.lineTo(x, y + size/6);
ctx.lineTo(x + size/6, y - size/6);
ctx.closePath();
ctx.fill();
}

// ç¹ªè£½æ˜Ÿæ˜Ÿçš„è¼”åŠ©å‡½æ•¸
function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
let rot = Math.PI / 2 * 3;
let x = cx;
let y = cy;
let step = Math.PI / spikes;
ctx.beginPath();
ctx.moveTo(cx, cy - outerRadius);
for (let i = 0; i < spikes; i++) {
x = cx + Math.cos(rot) * outerRadius;
y = cy + Math.sin(rot) * outerRadius;
ctx.lineTo(x, y);
rot += step;
x = cx + Math.cos(rot) * innerRadius;
y = cy + Math.sin(rot) * innerRadius;
ctx.lineTo(x, y);
rot += step;
}
ctx.lineTo(cx, cy - outerRadius);
ctx.closePath();
ctx.fill();
}

// ç¹ªè£½æ‰€æœ‰é“å…·
function drawPowerUps(offsetY) {
powerUps.forEach(powerUp => {
ctx.save();
ctx.translate(0, -offsetY);
const powerUpType = POWERUP_TYPES[powerUp.type];
if (powerUpType && powerUpType.drawFunction) {
powerUpType.drawFunction(powerUp.x, powerUp.y, powerUp.size);
}
ctx.restore();
});
}

// ç¹ªè£½è·¯ç·šåœ–ï¼ˆMini Mapï¼‰
function drawMiniMap() {
// æ¸…é™¤å°åœ°åœ–
miniMapCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
// è¨­ç½®ç¸®æ”¾å’Œåç§»
const scaleX = miniMapCanvas.width / canvas.width;
const scaleY = miniMapCanvas.height / canvas.height;
const scale = Math.min(scaleX, scaleY) * 0.8;
// é‡ç½®è®Šæ›
miniMapCtx.setTransform(1, 0, 0, 1, 0, 0);
// å°‡åŸé»ç§»è‡³ä¸­å¿ƒ
miniMapCtx.translate(miniMapCanvas.width / 2, miniMapCanvas.height / 2);
// ç¹ªè£½è³½é“è¼ªå»“
miniMapCtx.beginPath();
for (let i = 0; i < trackPoints.length; i++) {
const point = trackPoints[i];
const x = (point.x - canvas.width / 2) * scale;
const y = (point.y - canvas.height) * scale * 0.3; // å£“ç¸®Yè»¸
if (i === 0) miniMapCtx.moveTo(x, y);
else miniMapCtx.lineTo(x, y);
}
miniMapCtx.strokeStyle = '#333';
miniMapCtx.lineWidth = trackWidth * scale;
miniMapCtx.stroke();
// ç¹ªè£½è³½é“ä¸­å¿ƒç·š
miniMapCtx.beginPath();
for (let i = 0; i < trackPoints.length; i++) {
const point = trackPoints[i];
const x = (point.x - canvas.width / 2) * scale;
const y = (point.y - canvas.height) * scale * 0.3;
if (i === 0) miniMapCtx.moveTo(x, y);
else miniMapCtx.lineTo(x, y);
}
miniMapCtx.setLineDash([5, 3]);
miniMapCtx.strokeStyle = '#FFFFFF';
miniMapCtx.lineWidth = 2;
miniMapCtx.stroke();
miniMapCtx.setLineDash([]);
// ç¹ªè£½ç©å®¶ä½ç½®
const playerTrackPos = playerCar.trackPosition;
const playerPoint = getTrackPoint(playerTrackPos);
const playerX = (playerPoint.x - canvas.width / 2) * scale;
const playerY = (playerPoint.y - canvas.height) * scale * 0.3;
miniMapCtx.fillStyle = '#FF416C';
miniMapCtx.beginPath();
miniMapCtx.arc(playerX, playerY, 5, 0, Math.PI * 2);
miniMapCtx.fill();
// ç¹ªè£½çµ‚é»ä½ç½®
const finishPoint = getTrackPoint(1);
const finishX = (finishPoint.x - canvas.width / 2) * scale;
const finishY = (finishPoint.y - canvas.height) * scale * 0.3;
miniMapCtx.fillStyle = '#FFD700';
miniMapCtx.beginPath();
miniMapCtx.arc(finishX, finishY, 5, 0, Math.PI * 2);
miniMapCtx.fill();
// ç¹ªè£½æ–¹å‘ç®­é ­
miniMapCtx.fillStyle = '#FFFFFF';
miniMapCtx.font = '8px Arial';
miniMapCtx.textAlign = 'center';
miniMapCtx.fillText('â†‘', 0, -miniMapCanvas.height / 2 + 15);
}

// ç”Ÿæˆæ•µæ–¹è»Šè¼›
function generateEnemyCar() {
if (Math.random() < 0.02) { // 2% æ©Ÿç‡ç”Ÿæˆæ•µè»Š
const trackPos = Math.random() * 0.3; // æ•µè»Šå‡ºç¾åœ¨è³½é“å‰30%
const point = getTrackPoint(trackPos);
const direction = getTrackDirection(trackPos);
const perpendicularAngle = direction + Math.PI/2;
// éš¨æ©Ÿé¸æ“‡è³½é“å·¦å´æˆ–å³å´
const offsetX = (Math.random() - 0.5) * trackWidth * 0.7;
const x = point.x + Math.cos(perpendicularAngle) * offsetX;
const y = point.y;
const colors = ['#FF9800', '#9C27B0', '#2196F3', '#F44336'];
const color = colors[Math.floor(Math.random() * colors.length)];
let enemySpeed = 2 + Math.random() * 3;
// å¦‚æœæœ‰æ¸›é€Ÿæ•ˆæœï¼Œé™ä½æ•µè»Šé€Ÿåº¦
if (playerEffects.slowEnemy.active) {
enemySpeed *= 0.5;
}
enemyCars.push({
x: x,
y: y,
width: 40,
height: 70,
color: color,
angle: direction,
trackPosition: trackPos,
speed: enemySpeed
});
}
}

// ç”Ÿæˆé“å…·
function generatePowerUp() {
if (Math.random() < 0.01) { // 1% æ©Ÿç‡ç”Ÿæˆé“å…·
const trackPos = 0.1 + Math.random() * 0.8; // é“å…·å‡ºç¾åœ¨è³½é“10%-90%è™•
const point = getTrackPoint(trackPos);
const direction = getTrackDirection(trackPos);
const perpendicularAngle = direction + Math.PI/2;
// éš¨æ©Ÿé¸æ“‡è³½é“å·¦å´æˆ–å³å´
const offsetX = (Math.random() - 0.5) * trackWidth * 0.8;
const x = point.x + Math.cos(perpendicularAngle) * offsetX;
const y = point.y;
// éš¨æ©Ÿé¸æ“‡é“å…·é¡å‹
const powerUpTypes = Object.keys(POWERUP_TYPES);
const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
powerUps.push({
x: x,
y: y,
size: 30,
trackPosition: trackPos,
type: randomType
});
}
}

// æ›´æ–°æ•µæ–¹è»Šè¼›ä½ç½®
function updateEnemyCars() {
for (let i = enemyCars.length - 1; i >= 0; i--) {
const car = enemyCars[i];
// æ²¿è‘—è³½é“å‰é€²
car.trackPosition += car.speed / totalTrackLength;
if (car.trackPosition > 1) {
car.trackPosition = 0;
}
// ç²å–æ–°çš„ä½ç½®å’Œæ–¹å‘
const point = getTrackPoint(car.trackPosition);
const direction = getTrackDirection(car.trackPosition);
car.x = point.x;
car.y = point.y;
car.angle = direction;
// ç§»é™¤å¤ªé çš„è»Šè¼›ï¼ˆåœ¨ç•«é¢å¤–ï¼‰
if (car.y > playerCar.y + canvas.height) {
enemyCars.splice(i, 1);
}
}
}

// æ›´æ–°é“å…·ä½ç½®
function updatePowerUps() {
for (let i = powerUps.length - 1; i >= 0; i--) {
const powerUp = powerUps[i];
// æ²¿è‘—è³½é“å‰é€²
powerUp.trackPosition += 0.001; // é“å…·éš¨è³½é“ç§»å‹•
if (powerUp.trackPosition > 1) {
powerUp.trackPosition = 0;
}
// ç²å–æ–°çš„ä½ç½®
const point = getTrackPoint(powerUp.trackPosition);
powerUp.x = point.x;
powerUp.y = point.y;
// å¦‚æœæœ‰ç£éµæ•ˆæœä¸”é“å…·åœ¨ç¯„åœå…§ï¼Œå‘ç©å®¶ç§»å‹•
if (playerEffects.magnet.active) {
const dx = playerCar.x - powerUp.x;
const dy = playerCar.y - powerUp.y;
const distance = Math.sqrt(dx * dx + dy * dy);
if (distance < playerEffects.magnet.range) {
// å‘ç©å®¶ç§»å‹•
const speed = 2;
powerUp.x += (dx / distance) * speed;
powerUp.y += (dy / distance) * speed;
}
}
// ç§»é™¤å¤ªé çš„é“å…·
if (powerUp.y > playerCar.y + canvas.height) {
powerUps.splice(i, 1);
}
}
}

// æª¢æ¸¬ç¢°æ’
function checkCollisions() {
// æª¢æ¸¬èˆ‡æ•µæ–¹è»Šè¼›çš„ç¢°æ’
for (let i = enemyCars.length - 1; i >= 0; i--) {
const car = enemyCars[i];
const dx = playerCar.x - car.x;
const dy = playerCar.y - car.y;
const distance = Math.sqrt(dx * dx + dy * dy);
if (distance < (playerCar.width + car.width) / 2) {
// å¦‚æœæœ‰è­·ç›¾æ•ˆæœï¼Œä¸æå¤±ç”Ÿå‘½å€¼ï¼Œæ‘§æ¯€æ•µè»Š
if (playerEffects.shield.active) {
enemyCars.splice(i, 1);
score += 20; // æ‘§æ¯€æ•µè»Šçå‹µ
} else {
// ç¢°æ’ç™¼ç”Ÿ
enemyCars.splice(i, 1);
lives--;
speed = Math.max(0, speed - 5); // ç¢°æ’å¾Œæ¸›é€Ÿ
updateUI();
// å¦‚æœç”Ÿå‘½å€¼è€—ç›¡ï¼ŒéŠæˆ²çµæŸ
if (lives <= 0) {
endGame();
}
}
}
}
// æª¢æ¸¬èˆ‡é“å…·çš„ç¢°æ’
for (let i = powerUps.length - 1; i >= 0; i--) {
const powerUp = powerUps[i];
const dx = playerCar.x - powerUp.x;
const dy = playerCar.y - powerUp.y;
const distance = Math.sqrt(dx * dx + dy * dy);
if (distance < (playerCar.width + powerUp.size) / 2) {
// æ”¶é›†é“å…·
const powerUpType = POWERUP_TYPES[powerUp.type];
powerUps.splice(i, 1);
// æ ¹æ“šé“å…·é¡å‹æ‡‰ç”¨æ•ˆæœ
applyPowerUpEffect(powerUpType);
updateUI();
}
}
// æª¢æ¸¬æ˜¯å¦åé›¢è³½é“
checkOffTrack();
}

// æª¢æ¸¬æ˜¯å¦åé›¢è³½é“
function checkOffTrack() {
const direction = getTrackDirection(playerCar.trackPosition);
const perpendicularAngle = direction + Math.PI/2;
const trackCenter = getTrackPoint(playerCar.trackPosition);
const dx = playerCar.x - trackCenter.x;
const dy = playerCar.y - trackCenter.y;
const distanceToCenter = Math.abs(Math.cos(perpendicularAngle) * dx + Math.sin(perpendicularAngle) * dy);
// å¦‚æœåé›¢è³½é“ä¸­å¿ƒå¤ªé 
if (distanceToCenter > trackWidth/2 - playerCar.width/2) {
if (!playerEffects.shield.active) {
speed = Math.max(0, speed - 0.5); // æ¸›é€Ÿ
lives--;
updateUI();
if (lives <= 0) {
endGame();
}
}
}
}

// æ‡‰ç”¨é“å…·æ•ˆæœ
function applyPowerUpEffect(powerUpType) {
if (!powerUpType) return;
const now = Date.now();
const endTime = now + powerUpType.duration;
// æ ¹æ“šé“å…·é¡å‹è¨­ç½®æ•ˆæœ
switch(powerUpType.id) {
case 'shield':
playerEffects.shield.active = true;
playerEffects.shield.endTime = endTime;
playerCar.isInvulnerable = true;
break;
case 'slow':
playerEffects.slowEnemy.active = true;
playerEffects.slowEnemy.endTime = endTime;
break;
case 'double':
playerEffects.doubleScore.active = true;
playerEffects.doubleScore.endTime = endTime;
break;
case 'magnet':
playerEffects.magnet.active = true;
playerEffects.magnet.endTime = endTime;
break;
case 'speed':
playerEffects.speedBoost.active = true;
playerEffects.speedBoost.endTime = endTime;
playerCar.maxSpeed = maxSpeed + 5;
break;
}
// æ›´æ–°ç‹€æ…‹æ•ˆæœé¡¯ç¤º
updateStatusEffects();
// è¨­ç½®å®šæ™‚å™¨ç§»é™¤æ•ˆæœ
setTimeout(() => {
removePowerUpEffect(powerUpType.id);
}, powerUpType.duration);
}

// ç§»é™¤é“å…·æ•ˆæœ
function removePowerUpEffect(effectId) {
switch(effectId) {
case 'shield':
playerEffects.shield.active = false;
playerCar.isInvulnerable = false;
break;
case 'slow':
playerEffects.slowEnemy.active = false;
break;
case 'double':
playerEffects.doubleScore.active = false;
break;
case 'magnet':
playerEffects.magnet.active = false;
break;
case 'speed':
playerEffects.speedBoost.active = false;
playerCar.maxSpeed = maxSpeed;
break;
}
updateStatusEffects();
}

// æª¢æŸ¥æ•ˆæœæ˜¯å¦éæœŸ
function checkEffectsExpiry() {
const now = Date.now();
for (let effect in playerEffects) {
if (playerEffects[effect].active && now > playerEffects[effect].endTime) {
removePowerUpEffect(effect);
}
}
}

// æ›´æ–°ç©å®¶è»Šè¼›ä½ç½®
function updatePlayerCar() {
// åŠ é€Ÿ/æ¸›é€Ÿ
if (keys.ArrowUp && playerCar.speed < playerCar.maxSpeed) {
playerCar.speed += playerCar.acceleration;
if (playerCar.speed > playerCar.maxSpeed) playerCar.speed = playerCar.maxSpeed;
} else if (keys.ArrowDown) {
playerCar.speed -= playerCar.deceleration * 3;
if (playerCar.speed < 0) playerCar.speed = 0;
} else if (playerCar.speed > 0) {
playerCar.speed -= playerCar.deceleration;
if (playerCar.speed < 0) playerCar.speed = 0;
}
// è½‰å‘æ§åˆ¶
if (keys.ArrowLeft) {
playerCar.steering = -0.1;
} else if (keys.ArrowRight) {
playerCar.steering = 0.1;
} else {
playerCar.steering *= 0.9; // å¹³æ»‘å›æ­£
}
// æ›´æ–°è»Šè¼›åœ¨è³½é“ä¸Šçš„ä½ç½®
const distance = playerCar.speed * 2;
playerCar.trackPosition += distance / totalTrackLength;
if (playerCar.trackPosition >= 1) {
playerCar.trackPosition = 0;
currentLap++;
score += 100 * currentLap; // å®Œæˆä¸€åœˆçš„çå‹µ
}
// å–å¾—è³½é“ä¸Šå°æ‡‰çš„ä½ç½®
const trackPoint = getTrackPoint(playerCar.trackPosition);
const direction = getTrackDirection(playerCar.trackPosition);
// æ‡‰ç”¨è½‰å½æ•ˆæœ - è»Šè¼›è§’åº¦è·Ÿéš¨è³½é“æ–¹å‘
playerCar.angle = direction + playerCar.steering * 2;
// è¨ˆç®—åç§»ï¼ˆè½‰å½æ™‚è»Šè¼›å¯èƒ½æœƒåé›¢è³½é“ä¸­å¿ƒï¼‰
const perpendicularAngle = direction + Math.PI/2;
const offset = Math.sin(playerCar.steering * 5) * trackWidth * 0.3;
// è¨ˆç®—è»Šè¼›ä½ç½®
playerCar.x = trackPoint.x + Math.cos(perpendicularAngle) * offset;
playerCar.y = canvas.height - 150; // å›ºå®šåœ¨ç•«é¢åº•éƒ¨é™„è¿‘
// è¨ˆç®—è³½é“é€²åº¦ç™¾åˆ†æ¯”
trackProgress = (playerCar.trackPosition * 100);
// è¨ˆç®—åˆ†æ•¸ï¼ˆæ ¹æ“šé€Ÿåº¦å’Œåœ¨è³½é“ä¸Šçš„æ™‚é–“ï¼‰
if (playerCar.speed > 0) {
let points = Math.floor(playerCar.speed * 0.5);
if (playerEffects.doubleScore.active) points *= 2;
score += points;
}
// æ›´æ–°é€Ÿåº¦é¡¯ç¤º
speed = Math.round(playerCar.speed * 10);
}

// æ›´æ–°UI
function updateUI() {
scoreElement.textContent = score;
speedElement.textContent = speed + ' km/h';
livesElement.textContent = lives;
// æ›´æ–°é€²åº¦æ¢
progressFillElement.style.width = trackProgress + '%';
lapProgressElement.textContent = Math.floor(trackProgress);
}

// æ›´æ–°ç‹€æ…‹æ•ˆæœé¡¯ç¤º
function updateStatusEffects() {
statusEffectsElement.innerHTML = '';
for (let effectKey in playerEffects) {
const effect = playerEffects[effectKey];
if (effect.active && POWERUP_TYPES[effectKey.toUpperCase()]) {
const powerUpType = POWERUP_TYPES[effectKey.toUpperCase()];
const timeLeft = Math.max(0, Math.ceil((effect.endTime - Date.now()) / 1000));
const effectElement = document.createElement('div');
effectElement.className = 'status-effect';
effectElement.innerHTML = `
<div class="status-effect-icon ${effectKey}-icon"></div>
<span>${powerUpType.icon} ${powerUpType.name}: ${timeLeft}s</span>
`;
statusEffectsElement.appendChild(effectElement);
}
}
}

// çµæŸéŠæˆ²
function endGame() {
gameRunning = false;
finalScoreElement.textContent = score;
gameOverScreen.style.display = 'flex';
}

// éŠæˆ²ä¸»å¾ªç’°
function gameLoop() {
if (!gameRunning || gamePaused) {
requestAnimationFrame(gameLoop);
return;
}
// æ¸…é™¤ç•«å¸ƒ
ctx.clearRect(0, 0, canvas.width, canvas.height);
// è¨ˆç®—å‚ç›´åç§»ï¼Œä½¿è³½é“æ»¾å‹•
const offsetY = playerCar.y - (canvas.height - 150);
// ç¹ªè£½å½æ›²è³½é“
drawTrack(offsetY);
// æª¢æŸ¥æ•ˆæœæ˜¯å¦éæœŸ
checkEffectsExpiry();
// æ›´æ–°å’Œç¹ªè£½æ•µæ–¹è»Šè¼›
updateEnemyCars();
drawEnemyCars(offsetY);
// æ›´æ–°å’Œç¹ªè£½é“å…·
updatePowerUps();
drawPowerUps(offsetY);
// æ›´æ–°ç©å®¶è»Šè¼›
updatePlayerCar();
drawPlayerCar();
// æª¢æ¸¬ç¢°æ’
checkCollisions();
// éš¨æ©Ÿç”Ÿæˆæ•µæ–¹è»Šè¼›
generateEnemyCar();
// éš¨æ©Ÿç”Ÿæˆé“å…·
generatePowerUp();
// ç¹ªè£½å°åœ°åœ–
drawMiniMap();
// æ›´æ–°UI
updateUI();
// è«‹æ±‚ä¸‹ä¸€å¹€
requestAnimationFrame(gameLoop);
}

// äº‹ä»¶ç›£è½
document.addEventListener('keydown', (e) => {
if (keys.hasOwnProperty(e.key)) {
keys[e.key] = true;
// é«˜äº®é¡¯ç¤ºæŒ‰ä¸‹çš„éµ
switch(e.key) {
case 'ArrowUp':
keyUp.classList.add('active');
break;
case 'ArrowDown':
keyDown.classList.add('active');
break;
case 'ArrowLeft':
keyLeft.classList.add('active');
break;
case 'ArrowRight':
keyRight.classList.add('active');
break;
}
}
});

document.addEventListener('keyup', (e) => {
if (keys.hasOwnProperty(e.key)) {
keys[e.key] = false;
// ç§»é™¤é«˜äº®
switch(e.key) {
case 'ArrowUp':
keyUp.classList.remove('active');
break;
case 'ArrowDown':
keyDown.classList.remove('active');
break;
case 'ArrowLeft':
keyLeft.classList.remove('active');
break;
case 'ArrowRight':
keyRight.classList.remove('active');
break;
}
}
});

// æŒ‰éˆ•äº‹ä»¶
startButton.addEventListener('click', () => {
if (!gameRunning) {
initGame();
gameRunning = true;
gamePaused = false;
gameLoop();
startButton.textContent = 'é‡æ–°é–‹å§‹';
} else {
initGame();
gameRunning = true;
gamePaused = false;
gameLoop();
}
});

pauseButton.addEventListener('click', () => {
if (gameRunning) {
gamePaused = !gamePaused;
pauseButton.textContent = gamePaused ? 'ç¹¼çºŒéŠæˆ²' : 'æš«åœéŠæˆ²';
}
});

restartButton.addEventListener('click', () => {
initGame();
gameRunning = true;
gamePaused = false;
gameLoop();
gameOverScreen.style.display = 'none';
});

// åˆå§‹è¨­å®š
initGame();
drawTrack(0);
drawPlayerCar();
drawMiniMap();
updateUI();
updateStatusEffects();
</script>
</body>
</html>