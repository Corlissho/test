<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>å¡é€šè³½é“è³½è»Š</title>
<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}
body {
font-family: 'Arial', sans-serif;
background: linear-gradient(to bottom, #1a1a2e, #16213e);
color: #fff;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
min-height: 100vh;
padding: 20px;
position: relative;
}
.container {
max-width: 900px;
width: 100%;
text-align: center;
}
header {
margin-bottom: 20px;
}
h1 {
font-size: 2.8rem;
margin-bottom: 10px;
color: #FFD700;
text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
letter-spacing: 2px;
}
.subtitle {
font-size: 1.2rem;
color: #aaa;
margin-bottom: 20px;
}
.game-container {
position: relative;
margin: 0 auto 30px;
overflow: hidden;
border-radius: 10px;
box-shadow: 0 10px 30px rgba(0, 0, 0, 0.7);
}
#gameCanvas {
background-color: #0f3460;
display: block;
width: 100%;
}
/* é–‹å§‹æŒ‰éˆ•ç§»è‡³å³ä¸Šè§’ */
.top-controls {
position: absolute;
top: 20px;
right: 20px;
z-index: 100;
display: flex;
gap: 10px;
}
.top-controls button {
background: linear-gradient(to right, #FF416C, #FF4B2B);
border: none;
border-radius: 50px;
color: white;
padding: 10px 20px;
font-size: 1rem;
font-weight: bold;
cursor: pointer;
transition: all 0.3s;
box-shadow: 0 5px 15px rgba(255, 65, 108, 0.4);
}
.top-controls button:hover {
transform: translateY(-3px);
box-shadow: 0 8px 20px rgba(255, 65, 108, 0.6);
}
.top-controls button:active {
transform: translateY(1px);
}
.controls {
display: flex;
justify-content: space-between;
width: 100%;
max-width: 800px;
margin-bottom: 30px;
}
.control-panel {
background: rgba(255, 255, 255, 0.1);
border-radius: 10px;
padding: 20px;
flex: 1;
margin: 0 10px;
}
.control-panel h2 {
color: #4FC3F7;
margin-bottom: 15px;
font-size: 1.5rem;
}
.key-controls {
display: grid;
grid-template-columns: repeat(3, 1fr);
grid-template-rows: repeat(3, 1fr);
gap: 10px;
max-width: 200px;
margin: 0 auto;
}
.key {
background: rgba(0, 0, 0, 0.5);
border: 2px solid #4FC3F7;
border-radius: 8px;
padding: 15px;
font-size: 1.5rem;
font-weight: bold;
display: flex;
align-items: center;
justify-content: center;
color: white;
user-select: none;
transition: all 0.1s;
}
.key.active {
background: #4FC3F7;
transform: scale(0.95);
box-shadow: 0 0 15px #4FC3F7;
}
.key-up {
grid-column: 2;
grid-row: 1;
}
.key-left {
grid-column: 1;
grid-row: 2;
}
.key-down {
grid-column: 2;
grid-row: 2;
}
.key-right {
grid-column: 3;
grid-row: 2;
}
.game-info {
display: flex;
justify-content: space-around;
margin-top: 20px;
flex-wrap: wrap;
}
.info-box {
background: rgba(255, 255, 255, 0.1);
border-radius: 10px;
padding: 15px 25px;
min-width: 150px;
margin: 10px;
}
.info-title {
color: #FFD700;
font-size: 1rem;
margin-bottom: 5px;
}
.info-value {
font-size: 2rem;
font-weight: bold;
color: white;
}
.race-progress {
background: rgba(255, 255, 255, 0.1);
border-radius: 10px;
padding: 15px;
margin-top: 10px;
}
.progress-bar {
height: 20px;
background: rgba(0, 0, 0, 0.5);
border-radius: 10px;
overflow: hidden;
margin-top: 8px;
position: relative;
}
.progress-fill {
height: 100%;
background: linear-gradient(to right, #4FC3F7, #FFD700);
border-radius: 10px;
width: 0%;
transition: width 0.3s;
}
.mini-map-container {
position: absolute;
bottom: 20px;
right: 20px;
background: rgba(0, 0, 0, 0.7);
border-radius: 10px;
padding: 10px;
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
z-index: 50;
}
#miniMap {
width: 150px;
height: 150px;
display: block;
}
.instructions {
background: rgba(255, 255, 255, 0.1);
border-radius: 10px;
padding: 20px;
margin-top: 30px;
text-align: left;
max-width: 800px;
}
.instructions h2 {
color: #4FC3F7;
margin-bottom: 15px;
text-align: center;
}
.instructions ul {
padding-left: 20px;
margin-bottom: 15px;
}
.instructions li {
margin-bottom: 8px;
line-height: 1.5;
}
.instructions p {
color: #aaa;
font-style: italic;
text-align: center;
}
.game-over {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.85);
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
z-index: 10;
display: none;
}
.game-over h2 {
font-size: 3.5rem;
color: #FF416C;
margin-bottom: 20px;
}
.game-over p {
font-size: 1.5rem;
margin-bottom: 30px;
}
.status-effects {
display: flex;
justify-content: center;
gap: 15px;
margin-top: 10px;
flex-wrap: wrap;
}
.status-effect {
background: rgba(255, 255, 255, 0.15);
border-radius: 8px;
padding: 8px 15px;
font-size: 0.9rem;
display: flex;
align-items: center;
gap: 8px;
}
.status-effect-icon {
width: 20px;
height: 20px;
border-radius: 50%;
}
.shield-icon { background-color: #4CAF50; }
.double-icon { background-color: #9C27B0; }
.magnet-icon { background-color: #2196F3; }
/* å€’è¨ˆæ™‚æ¨£å¼ */
.countdown-overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: rgba(0, 0, 0, 0.7);
display: flex;
justify-content: center;
align-items: center;
z-index: 100;
display: none;
}

.countdown-number {
font-size: 8rem;
color: #FFD700;
text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
animation: pulse 1s infinite;
}

@keyframes pulse {
0% { transform: scale(1); opacity: 1; }
50% { transform: scale(1.2); opacity: 0.8; }
100% { transform: scale(1); opacity: 1; }
}

@media (max-width: 768px) {
.controls {
flex-direction: column;
}
.control-panel {
margin: 10px 0;
}
.game-info {
flex-direction: column;
align-items: center;
}
.status-effects {
flex-direction: column;
align-items: center;
}
.top-controls {
position: static;
margin-bottom: 15px;
flex-wrap: wrap;
}
.mini-map-container {
position: static;
margin-top: 15px;
}
.countdown-number {
font-size: 6rem;
}

/* ç§»å‹•ç«¯æŒ‰éˆ•å’Œè§¸æ§å„ªåŒ– */
.top-controls button {
min-height: 50px;
min-width: 120px;
font-size: 16px;
margin: 5px;
}

.key {
min-height: 60px;
min-width: 60px;
font-size: 1.8rem;
margin: 4px;
}

.control-panel button {
min-height: 44px;
font-size: 14px;
}

/* å¢å¤§è§¸æ§ç›®æ¨™ */
.info-box {
min-width: 120px;
padding: 20px;
margin: 8px;
}

.game-info {
padding: 20px;
}

/* é˜²æ­¢ç§»å‹•ç«¯æ„å¤–ç¸®æ”¾ */
body {
touch-action: manipulation;
-ms-touch-action: manipulation;
}
}

/* è§¸æ§è¨­å‚™å°ˆç”¨æ¨£å¼ */
@media (hover: none) and (pointer: coarse) {
.key:active {
transform: scale(0.9);
background: #4FC3F7;
}

.top-controls button:active {
transform: scale(0.95);
}

.cell, .interactive-element {
touch-action: manipulation;
}

/* ç§»é™¤é•·æŒ‰é¸å–® */
-webkit-user-select: none;
-moz-user-select: none;
-ms-user-select: none;
user-select: none;
-webkit-touch-callout: none;
}
</style>
</head>
<body>
<div class="container">
<header>
<h1>å¡é€šè³½é“è³½è»Š</h1>
<p class="subtitle">ä½¿ç”¨æ–¹å‘éµæ§åˆ¶è·‘è»Šï¼Œé¿é–‹éšœç¤™ç‰©ï¼Œçˆ­å–æœ€é«˜åˆ†æ•¸ï¼</p>
</header>
<div class="game-container">
<canvas id="gameCanvas" width="800" height="600"></canvas>
<div class="mini-map-container">
<canvas id="miniMap" width="150" height="150"></canvas>
<div style="text-align: center; margin-top: 5px; font-size: 0.8rem; color: #FFD700;">è³½é“åœ°åœ–</div>
</div>
<div class="countdown-overlay" id="countdownOverlay">
<div class="countdown-number" id="countdownNumber">3</div>
</div>
<div class="top-controls">
<button id="startButton">é–‹å§‹éŠæˆ²</button>
<button id="pauseButton">æš«åœéŠæˆ²</button>
</div>
<div class="game-over" id="gameOverScreen">
<h2>éŠæˆ²çµæŸï¼</h2>
<p>ä½ çš„åˆ†æ•¸ï¼š<span id="finalScore">0</span></p>
<button id="restartButton">é‡æ–°é–‹å§‹</button>
</div>
</div>
<div class="controls">
<div class="control-panel">
<h2>æ§åˆ¶éµ</h2>
<div class="key-controls">
<div class="key key-up" id="keyUp">â†‘</div>
<div class="key key-left" id="keyLeft">â†</div>
<div class="key key-down" id="keyDown">â†“</div>
<div class="key key-right" id="keyRight">â†’</div>
</div>
</div>
<div class="control-panel">
<h2>éŠæˆ²ç‹€æ…‹</h2>
<div class="game-info">
<div class="info-box">
<div class="info-title">åˆ†æ•¸</div>
<div class="info-value" id="score">0</div>
</div>
<div class="info-box">
<div class="info-title">é€Ÿåº¦</div>
<div class="info-value" id="speed">0 km/h</div>
</div>
<div class="info-box">
<div class="info-title">ç”Ÿå‘½å€¼</div>
<div class="info-value" id="lives">3</div>
</div>
</div>
<div class="race-progress">
<div class="info-title">è³½é“é€²åº¦</div>
<div class="progress-bar">
<div class="progress-fill" id="progressFill"></div>
</div>
<div style="text-align: right; font-size: 0.9rem; margin-top: 5px; color: #FFD700;">
<span id="lapProgress">0</span>% / 100%
</div>
</div>
<div class="status-effects" id="statusEffects">
</div>
</div>
</div>
<div class="instructions">
<h2>éŠæˆ²èªªæ˜</h2>
<ul>
<li>ä½¿ç”¨ <strong>â†‘ ä¸‹éµ</strong> åŠ é€Ÿ/æ¸›é€Ÿ</li>
<li>ä½¿ç”¨ <strong>â† â†’ éµ</strong> å·¦å³ç§»å‹•æ§åˆ¶æ–¹å‘</li>
<li>é¿é–‹å…¶ä»–è»Šè¼›ï¼Œæ’åˆ°æœƒæå¤±ç”Ÿå‘½å€¼</li>
<li>ä¿æŒåœ¨è³½é“ä¸Šä»¥ç²å¾—æŒçºŒåŠ åˆ†</li>
<li><strong>æ–°é“å…·ç³»çµ±ï¼š</strong></li>
<li style="margin-left: 20px;">ğŸŸ¢ <strong>è­·ç›¾</strong>ï¼šç¶ è‰²åœ“åœˆï¼Œ3ç§’ç„¡æ•µ</li>
<li style="margin-left: 20px;">ğŸŸ£ <strong>åˆ†æ•¸åŠ å€</strong>ï¼šç´«è‰²æ˜Ÿæ˜Ÿï¼Œ30ç§’å…§åˆ†æ•¸åŠ å€</li>
<li style="margin-left: 20px;">ğŸ”µ <strong>ç£éµ</strong>ï¼šè—è‰²ç£éµï¼Œè‡ªå‹•å¸å¼•é™„è¿‘é“å…·</li>
<li>å®Œæˆä¸€åœˆè³½é“å¯ç²å¾—çå‹µåˆ†æ•¸</li>
<li>éŠæˆ²ç›®æ¨™ï¼šåœ¨ä¸€åœˆå…§ç²å¾—æœ€é«˜åˆ†ï¼</li>
</ul>
<p>æ³¨æ„ï¼šè»Šé€Ÿè¶Šå¿«ï¼Œæ§åˆ¶è¶Šå›°é›£ï¼</p>
</div>
</div>
<script>
// éŠæˆ²è®Šæ•¸
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const miniMapCanvas = document.getElementById('miniMap');
const miniMapCtx = miniMapCanvas.getContext('2d');
const scoreElement = document.getElementById('score');
const speedElement = document.getElementById('speed');
const livesElement = document.getElementById('lives');
const startButton = document.getElementById('startButton');
const pauseButton = document.getElementById('pauseButton');
const restartButton = document.getElementById('restartButton');
const gameOverScreen = document.getElementById('gameOverScreen');
const finalScoreElement = document.getElementById('finalScore');
const statusEffectsElement = document.getElementById('statusEffects');
const progressFillElement = document.getElementById('progressFill');
const lapProgressElement = document.getElementById('lapProgress');
const countdownOverlay = document.getElementById('countdownOverlay');
const countdownNumber = document.getElementById('countdownNumber');

// æ§åˆ¶éµå…ƒç´ 
const keyUp = document.getElementById('keyUp');
const keyDown = document.getElementById('keyDown');
const keyLeft = document.getElementById('keyLeft');
const keyRight = document.getElementById('keyRight');

// ç¾ä»£åˆæˆéŸ³æ•ˆç³»çµ±
class GameAudio {
    constructor() {
        this.audioContext = null;
        this.enabled = true;
        this.volume = 0.3;
        this.masterVolume = 0.3;
        this.initAudioContext();
    }

    initAudioContext() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGainNode = this.audioContext.createGain();
            this.masterGainNode.connect(this.audioContext.destination);
            this.masterGainNode.gain.value = this.masterVolume;
        } catch (e) {
            console.warn('Audio not supported:', e);
            this.enabled = false;
        }
    }

    resumeAudio() {
        if (this.audioContext && this.audioContext.state === 'suspended') {
            this.audioContext.resume();
        }
    }

    createSynthSound(frequency, duration, type = 'sine', modulation = null) {
        if (!this.enabled || !this.audioContext) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const filter = this.audioContext.createBiquadFilter();
        
        // é€£æ¥éŸ³é »ç¯€é»
        oscillator.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(this.masterGainNode);
        
        // åŸºç¤è¨­ç½®
        oscillator.type = type;
        oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
        
        // ç¾ä»£åˆæˆå™¨æ¿¾æ³¢å™¨è¨­ç½®
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(2000, this.audioContext.currentTime);
        filter.Q.setValueAtTime(10, this.audioContext.currentTime);
        
        // ADSRåŒ…çµ¡
        const now = this.audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(this.volume, now + 0.01); // Attack
        gainNode.gain.exponentialRampToValueAtTime(this.volume * 0.7, now + 0.1); // Decay/Sustain
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration); // Release
        
        // æ·»åŠ èª¿åˆ¶æ•ˆæœ
        if (modulation) {
            const lfo = this.audioContext.createOscillator();
            const lfoGain = this.audioContext.createGain();
            
            lfo.frequency.value = modulation.frequency || 5;
            lfoGain.gain.value = modulation.amount || 10;
            
            lfo.connect(lfoGain);
            lfoGain.connect(oscillator.frequency);
            lfo.start(now);
            lfo.stop(now + duration);
        }
        
        oscillator.start(now);
        oscillator.stop(now + duration);
    }

    // å…·é«”éŸ³æ•ˆæ–¹æ³•
    playEngineIdle() {
        this.createSynthSound(80, 0.1, 'sawtooth', { frequency: 2, amount: 5 });
    }

    playEngineRev() {
        this.createSynthSound(120, 0.2, 'sawtooth', { frequency: 8, amount: 15 });
    }

    playCollision() {
        // ç¢°æ’éŸ³æ•ˆ - å™ªéŸ³ + ä½é »è¡æ“Š
        this.createSynthSound(60, 0.3, 'square');
        setTimeout(() => this.createSynthSound(30, 0.2, 'sawtooth'), 50);
    }

    playPowerUp(type) {
        switch(type) {
            case 'shield':
                this.createSynthSound(440, 0.15, 'sine', { frequency: 6, amount: 20 });
                setTimeout(() => this.createSynthSound(660, 0.15, 'sine'), 100);
                break;
            case 'double':
                this.createSynthSound(523, 0.1, 'triangle', { frequency: 12, amount: 30 });
                setTimeout(() => this.createSynthSound(784, 0.1, 'triangle'), 50);
                setTimeout(() => this.createSynthSound(1047, 0.15, 'triangle'), 100);
                break;
            case 'magnet':
                this.createSynthSound(200, 0.2, 'sine', { frequency: 3, amount: 50 });
                break;
        }
    }

    playButtonClick() {
        this.createSynthSound(600, 0.08, 'sine');
    }

    playCountdown(number) {
        const frequency = 800 - (number * 100);
        this.createSynthSound(frequency, 0.2, 'square');
    }

    playGameOver() {
        this.createSynthSound(300, 0.3, 'sawtooth');
        setTimeout(() => this.createSynthSound(250, 0.3, 'sawtooth'), 150);
        setTimeout(() => this.createSynthSound(200, 0.4, 'sawtooth'), 300);
    }

    playLapComplete() {
        // å‹åˆ©æ—‹å¾‹
        const notes = [523, 659, 784, 1047]; // C, E, G, High C
        notes.forEach((note, i) => {
            setTimeout(() => this.createSynthSound(note, 0.2, 'triangle', { frequency: 8, amount: 15 }), i * 100);
        });
    }

    playLaneChange() {
        this.createSynthSound(400, 0.05, 'square');
    }
}

// åˆå§‹åŒ–éŸ³æ•ˆç³»çµ±
const gameAudio = new GameAudio();

// ç²’å­æ•ˆæœç³»çµ±
class ParticleSystem {
    constructor(canvas, ctx) {
        this.canvas = canvas;
        this.ctx = ctx;
        this.particles = [];
        this.maxParticles = 100;
    }

    createExplosion(x, y, color = '#FFD700', count = 20) {
        if (this.particles.length + count > this.maxParticles) {
            this.particles.splice(0, this.particles.length + count - this.maxParticles);
        }

        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5;
            const speed = 2 + Math.random() * 4;
            const size = 2 + Math.random() * 4;
            
            this.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                color: color,
                size: size,
                gravity: 0.1
            });
        }
    }

    createPowerUpTrail(x, y, color) {
        if (this.particles.length >= this.maxParticles - 5) return;
        
        for (let i = 0; i < 3; i++) {
            this.particles.push({
                x: x + Math.random() * 10 - 5,
                y: y + Math.random() * 10 - 5,
                vx: (Math.random() - 0.5) * 1,
                vy: Math.random() * 1 + 1,
                life: 0.8,
                color: color,
                size: 2,
                gravity: 0
            });
        }
    }

    createSpeedLines(x, y) {
        if (this.particles.length >= this.maxParticles - 10) return;
        
        for (let i = 0; i < 5; i++) {
            this.particles.push({
                x: x + Math.random() * 40 - 20,
                y: y + Math.random() * 60,
                vx: 0,
                vy: -8 - Math.random() * 4,
                life: 0.6,
                color: 'rgba(79, 195, 247, 0.8)',
                size: 1,
                gravity: 0
            });
        }
    }

    update() {
        this.particles = this.particles.filter(particle => {
            particle.x += particle.vx;
            particle.y += particle.vy;
            particle.vy += particle.gravity;
            particle.life -= 0.02;
            particle.vx *= 0.98; // ç©ºæ°£é˜»åŠ›
            particle.vy *= 0.98;
            
            return particle.life > 0;
        });
    }

    draw() {
        this.particles.forEach(particle => {
            this.ctx.save();
            this.ctx.globalAlpha = particle.life;
            this.ctx.fillStyle = particle.color;
            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = particle.color;
            
            this.ctx.beginPath();
            this.ctx.arc(particle.x, particle.y, particle.size * particle.life, 0, Math.PI * 2);
            this.ctx.fill();
            
            this.ctx.restore();
        });
    }
}

// åˆå§‹åŒ–ç²’å­ç³»çµ±
const particleSystem = new ParticleSystem(canvas, ctx);

// éŠæˆ²ç‹€æ…‹
let gameRunning = false;
let gamePaused = false;
let countDownActive = false;
let score = 0;
let lives = 3;
let speed = 0;
let trackProgress = 0; // è³½é“é€²åº¦ (0-100%)
const totalTrackLength = 3000; // ç¸½è³½é“é•·åº¦ï¼ˆå–®ä½ï¼‰
let currentLap = 0;
let maxSpeed = 15;
let acceleration = 0.2;
let deceleration = 0.1;
let gameFrameId = null;
let gameInitialized = false;

// ç°¡å–®è³½é“è¨­å®š
const trackCount = 3;
const trackWidth = canvas.width / trackCount;
const trackColors = ['#2E8B57', '#228B22', '#006400'];
const laneMarkings = [];
for (let i = 1; i < trackCount; i++) {
    laneMarkings.push({
        x: i * trackWidth,
        y: 0,
        width: 10,
        height: 40,
        gap: 20
    });
}

// é“å…·é¡å‹å®šç¾©
const POWERUP_TYPES = {
    SHIELD: {
        id: 'shield',
        name: 'è­·ç›¾',
        color: '#4CAF50',
        duration: 3000,
        icon: 'ğŸ›¡ï¸',
        drawFunction: drawShieldPowerUp
    },
    DOUBLE_SCORE: {
        id: 'double',
        name: 'åˆ†æ•¸åŠ å€',
        color: '#9C27B0',
        duration: 30000,
        icon: 'â­',
        drawFunction: drawDoubleScorePowerUp
    },
    MAGNET: {
        id: 'magnet',
        name: 'ç£éµ',
        color: '#2196F3',
        duration: 10000,
        icon: 'ğŸ§²',
        drawFunction: drawMagnetPowerUp
    }
};

// ç©å®¶ç‹€æ…‹æ•ˆæœ
let playerEffects = {
    shield: { active: false, endTime: 0 },
    doubleScore: { active: false, endTime: 0 },
    magnet: { active: false, endTime: 0, range: 200 }
};

// ç©å®¶è»Šè¼›
const playerCar = {
    x: canvas.width / 2 - 25,
    y: canvas.height - 120,
    width: 50,
    height: 100,
    color: '#FF416C',
    track: 1,
    speed: 0,
    maxSpeed: maxSpeed,
    acceleration: acceleration,
    deceleration: deceleration,
    isInvulnerable: false
};

// æ•µæ–¹è»Šè¼›é™£åˆ—
let enemyCars = [];
// é“å…·é™£åˆ—
let powerUps = [];
// æ§åˆ¶ç‹€æ…‹
const keys = {
    ArrowUp: false,
    ArrowDown: false,
    ArrowLeft: false,
    ArrowRight: false
};

// åˆå§‹åŒ–éŠæˆ²è³‡æº
window.addEventListener('load', () => {
    initGame(); // æ­¤å‡½æ•¸å…§éƒ¨å·²åŒ…å« drawInitialScene()
    gameInitialized = true;
});

// åˆå§‹åŒ–éŠæˆ²
function initGame() {
    score = 0;
    lives = 3;
    speed = 0;
    trackProgress = 0;
    currentLap = 0;
    playerCar.x = canvas.width / 2 - 25;
    playerCar.y = canvas.height - 120;
    playerCar.track = 1;
    playerCar.speed = 0;
    playerCar.isInvulnerable = false;
    enemyCars = [];
    powerUps = [];
    // é‡ç½®æ‰€æœ‰æ•ˆæœ
    for (let effect in playerEffects) {
        playerEffects[effect].active = false;
        playerEffects[effect].endTime = 0;
    }
    gameOverScreen.style.display = 'none';
    countdownOverlay.style.display = 'none';
    updateUI();
    updateStatusEffects();
    
    // âœ… é—œéµä¿®å¾©ï¼šç¢ºä¿ç•«å¸ƒç«‹å³é¡¯ç¤ºè³½è»Š
    drawInitialScene();
    
    // é‡ç½®æŒ‰éˆ•ç‹€æ…‹
    startButton.textContent = 'é–‹å§‹éŠæˆ²';
    pauseButton.textContent = 'æš«åœéŠæˆ²';
}

// ç¹ªè£½åˆå§‹å ´æ™¯
function drawInitialScene() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTracks();
    drawPlayerCar();
    drawMiniMap();
}

// ç¹ªè£½è³½é“
function drawTracks() {
    for (let i = 0; i < trackCount; i++) {
        ctx.fillStyle = trackColors[i];
        ctx.fillRect(i * trackWidth, 0, trackWidth, canvas.height);
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(i * trackWidth, 0, 5, canvas.height);
        ctx.fillRect((i + 1) * trackWidth - 5, 0, 5, canvas.height);
    }

    laneMarkings.forEach(marking => {
        for (let y = 0; y < canvas.height; y += marking.height + marking.gap) {
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(marking.x - marking.width/2, y, marking.width, marking.height);
        }
    });

    drawBackground();
}

// ç¹ªè£½èƒŒæ™¯
function drawBackground() {
    ctx.fillStyle = 'rgba(15, 52, 96, 0.7)';
    ctx.beginPath();
    ctx.moveTo(0, 100);
    ctx.lineTo(150, 50);
    ctx.lineTo(300, 120);
    ctx.lineTo(500, 80);
    ctx.lineTo(700, 130);
    ctx.lineTo(800, 90);
    ctx.lineTo(800, 0);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
    drawCloud(100, 60, 40);
    drawCloud(400, 40, 30);
    drawCloud(600, 80, 50);
}

// ç¹ªè£½é›²æœµ
function drawCloud(x, y, size) {
    ctx.beginPath();
    ctx.arc(x, y, size, 0, Math.PI * 2);
    ctx.arc(x + size * 0.8, y - size * 0.3, size * 0.7, 0, Math.PI * 2);
    ctx.arc(x + size * 1.5, y, size * 0.8, 0, Math.PI * 2);
    ctx.arc(x + size * 0.8, y + size * 0.3, size * 0.7, 0, Math.PI * 2);
    ctx.fill();
}

// ç¹ªè£½ç©å®¶è»Šè¼›
function drawPlayerCar() {
    if (playerEffects.shield.active) {
        ctx.strokeStyle = '#4CAF50';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(
            playerCar.x + playerCar.width/2,
            playerCar.y + playerCar.height/2,
            Math.max(playerCar.width, playerCar.height)/2 + 15,
            0, Math.PI * 2
        );
        ctx.stroke();
        const pulse = (Date.now() % 1000) / 1000;
        ctx.globalAlpha = 0.3 + 0.2 * Math.sin(pulse * Math.PI * 2);
        ctx.fillStyle = '#4CAF50';
        ctx.beginPath();
        ctx.arc(
            playerCar.x + playerCar.width/2,
            playerCar.y + playerCar.height/2,
            Math.max(playerCar.width, playerCar.height)/2 + 10,
            0, Math.PI * 2
        );
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }

    ctx.fillStyle = playerCar.color;
    ctx.fillRect(playerCar.x, playerCar.y, playerCar.width, playerCar.height);

    if (playerEffects.magnet.active) {
        ctx.strokeStyle = '#2196F3';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.arc(
            playerCar.x + playerCar.width/2,
            playerCar.y + playerCar.height/2,
            playerEffects.magnet.range,
            0, Math.PI * 2
        );
        ctx.stroke();
        ctx.setLineDash([]);
    }

    ctx.fillStyle = '#4FC3F7';
    ctx.fillRect(playerCar.x + 5, playerCar.y + 10, playerCar.width - 10, 30);

    ctx.fillStyle = '#FFD700';
    ctx.fillRect(playerCar.x + 5, playerCar.y + playerCar.height - 15, 10, 10);
    ctx.fillRect(playerCar.x + playerCar.width - 15, playerCar.y + playerCar.height - 15, 10, 10);

    ctx.fillStyle = '#222';
    ctx.fillRect(playerCar.x - 5, playerCar.y + 15, 5, 25);
    ctx.fillRect(playerCar.x + playerCar.width, playerCar.y + 15, 5, 25);
    ctx.fillRect(playerCar.x - 5, playerCar.y + playerCar.height - 40, 5, 25);
    ctx.fillRect(playerCar.x + playerCar.width, playerCar.y + playerCar.height - 40, 5, 25);
}

// ç¹ªè£½æ•µæ–¹è»Šè¼›
function drawEnemyCars() {
    enemyCars.forEach(car => {
        ctx.fillStyle = car.color;
        ctx.fillRect(car.x, car.y, car.width, car.height);

        ctx.fillStyle = '#999';
        ctx.fillRect(car.x + 5, car.y + 10, car.width - 10, 20);

        ctx.fillStyle = '#222';
        ctx.fillRect(car.x - 5, car.y + 15, 5, 20);
        ctx.fillRect(car.x + car.width, car.y + 15, 5, 20);
        ctx.fillRect(car.x - 5, car.y + car.height - 35, 5, 20);
        ctx.fillRect(car.x + car.width, car.y + car.height - 35, 5, 20);
    });
}

// ç¹ªè£½è­·ç›¾é“å…·
function drawShieldPowerUp(x, y, size) {
    ctx.strokeStyle = '#4CAF50';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
    ctx.stroke();

    ctx.fillStyle = '#4CAF50';
    ctx.beginPath();
    ctx.arc(x + size/2, y + size/2, size/3, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.moveTo(x + size/2, y + size/4);
    ctx.lineTo(x + size/4, y + size/2);
    ctx.lineTo(x + size/2, y + size*3/4);
    ctx.lineTo(x + size*3/4, y + size/2);
    ctx.closePath();
    ctx.fill();
}

// ç¹ªè£½åˆ†æ•¸åŠ å€é“å…·
function drawDoubleScorePowerUp(x, y, size) {
    ctx.fillStyle = '#9C27B0';
    ctx.beginPath();
    ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#FFFFFF';
    drawStar(ctx, x + size/2, y + size/2, 5, size/4, size/8);
}

// ç¹ªè£½ç£éµé“å…·
function drawMagnetPowerUp(x, y, size) {
    ctx.fillStyle = '#2196F3';
    ctx.beginPath();
    ctx.arc(x + size/2, y + size/2, size/2, 0, Math.PI * 2);
    ctx.fill();

    ctx.fillStyle = '#FFFFFF';
    ctx.beginPath();
    ctx.arc(x + size/2, y + size/2, size/3, Math.PI * 0.25, Math.PI * 0.75);
    ctx.arc(x + size/2, y + size/2, size/3, Math.PI * 1.25, Math.PI * 1.75);
    ctx.closePath();
    ctx.fill();
}

// ç¹ªè£½æ˜Ÿæ˜Ÿ
function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
    let rot = Math.PI / 2 * 3;
    let step = Math.PI / spikes;
    ctx.beginPath();
    ctx.moveTo(cx, cy - outerRadius);
    for (let i = 0; i < spikes; i++) {
        let x = cx + Math.cos(rot) * outerRadius;
        let y = cy + Math.sin(rot) * outerRadius;
        ctx.lineTo(x, y);
        rot += step;
        x = cx + Math.cos(rot) * innerRadius;
        y = cy + Math.sin(rot) * innerRadius;
        ctx.lineTo(x, y);
        rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fill();
}

// ç¹ªè£½æ‰€æœ‰é“å…·
function drawPowerUps() {
    powerUps.forEach(powerUp => {
        const powerUpType = POWERUP_TYPES[powerUp.type];
        if (powerUpType && powerUpType.drawFunction) {
            powerUpType.drawFunction(powerUp.x, powerUp.y, powerUp.size);
        }
    });
}

// ç”Ÿæˆæ•µæ–¹è»Šè¼›
function generateEnemyCar() {
    const track = Math.floor(Math.random() * trackCount);
    const x = track * trackWidth + (trackWidth - 50) / 2;
    const y = -100;
    const colors = ['#FF9800', '#9C27B0', '#2196F3', '#F44336'];
    const color = colors[Math.floor(Math.random() * colors.length)];
    let enemySpeed = 3 + Math.random() * 5;
    enemyCars.push({
        x: x,
        y: y,
        width: 50,
        height: 100,
        color: color,
        track: track,
        speed: enemySpeed
    });
}

// ç”Ÿæˆé“å…·
function generatePowerUp() {
    if (Math.random() < 0.015) {
        const track = Math.floor(Math.random() * trackCount);
        const x = track * trackWidth + (trackWidth - 30) / 2;
        const y = -30;
        const powerUpTypes = Object.keys(POWERUP_TYPES);
        const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
        powerUps.push({
            x: x,
            y: y,
            size: 30,
            track: track,
            type: randomType
        });
    }
}

// æ›´æ–°æ•µæ–¹è»Šè¼›
function updateEnemyCars() {
    for (let i = enemyCars.length - 1; i >= 0; i--) {
        enemyCars[i].y += enemyCars[i].speed;
        if (enemyCars[i].y > canvas.height) {
            enemyCars.splice(i, 1);
            let points = 10;
            if (playerEffects.doubleScore.active) {
                points *= 2;
            }
            score += points;
        }
    }
}

// æ›´æ–°é“å…·
function updatePowerUps() {
    for (let i = powerUps.length - 1; i >= 0; i--) {
        const powerUp = powerUps[i];
        if (playerEffects.magnet.active) {
            const dx = (playerCar.x + playerCar.width/2) - (powerUp.x + powerUp.size/2);
            const dy = (playerCar.y + playerCar.height/2) - (powerUp.y + powerUp.size/2);
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance < playerEffects.magnet.range) {
                const speed = 8;
                powerUp.x += (dx / distance) * speed;
                powerUp.y += (dy / distance) * speed;
            } else {
                powerUp.y += 5;
            }
        } else {
            powerUp.y += 5;
        }
        if (powerUp.y > canvas.height) {
            powerUps.splice(i, 1);
        }
    }
}

// æª¢æ¸¬ç¢°æ’
function checkCollisions() {
    for (let i = enemyCars.length - 1; i >= 0; i--) {
        const car = enemyCars[i];
        if (
            playerCar.x < car.x + car.width &&
            playerCar.x + playerCar.width > car.x &&
            playerCar.y < car.y + car.height &&
            playerCar.y + playerCar.height > car.y
        ) {
        if (playerEffects.shield.active) {
                particleSystem.createExplosion(car.x + car.width/2, car.y + car.height/2, '#4CAF50', 15);
                enemyCars.splice(i, 1);
                score += 20;
                gameAudio.playPowerUp('shield'); // è­·ç›¾ç¢°æ’éŸ³æ•ˆ
            } else {
                particleSystem.createExplosion(car.x + car.width/2, car.y + car.height/2, '#FF416C', 25);
                enemyCars.splice(i, 1);
                lives--;
                gameAudio.playCollision(); // ç¢°æ’éŸ³æ•ˆ
                updateUI();
                if (lives <= 0) {
                    gameAudio.playGameOver(); // éŠæˆ²çµæŸéŸ³æ•ˆ
                    endGame();
                }
            }
            return;
        }
    }

    for (let i = powerUps.length - 1; i >= 0; i--) {
        const powerUp = powerUps[i];
        if (
            playerCar.x < powerUp.x + powerUp.size &&
            playerCar.x + playerCar.width > powerUp.x &&
            playerCar.y < powerUp.y + powerUp.size &&
            playerCar.y + playerCar.height > powerUp.y
        ) {
            const powerUpType = POWERUP_TYPES[powerUp.type];
            powerUps.splice(i, 1);
            gameAudio.playPowerUp(powerUp.type); // é“å…·æ‹¾å–éŸ³æ•ˆ
            particleSystem.createExplosion(powerUp.x + powerUp.size/2, powerUp.y + powerUp.size/2, powerUpType.color, 12);
            applyPowerUpEffect(powerUpType);
            updateUI();
        }
    }
}

// æ‡‰ç”¨é“å…·æ•ˆæœ
function applyPowerUpEffect(powerUpType) {
    if (!powerUpType) return;
    const now = Date.now();
    const endTime = now + powerUpType.duration;
    switch(powerUpType.id) {
        case 'shield':
            playerEffects.shield.active = true;
            playerEffects.shield.endTime = endTime;
            playerCar.isInvulnerable = true;
            break;
        case 'double':
            playerEffects.doubleScore.active = true;
            playerEffects.doubleScore.endTime = endTime;
            break;
        case 'magnet':
            playerEffects.magnet.active = true;
            playerEffects.magnet.endTime = endTime;
            break;
    }
    updateStatusEffects();
    setTimeout(() => {
        removePowerUpEffect(powerUpType.id);
    }, powerUpType.duration);
}

// ç§»é™¤é“å…·æ•ˆæœ
function removePowerUpEffect(effectId) {
    switch(effectId) {
        case 'shield':
            playerEffects.shield.active = false;
            playerCar.isInvulnerable = false;
            break;
        case 'double':
            playerEffects.doubleScore.active = false;
            break;
        case 'magnet':
            playerEffects.magnet.active = false;
            break;
    }
    updateStatusEffects();
}

// æª¢æŸ¥æ•ˆæœæ˜¯å¦éæœŸ
function checkEffectsExpiry() {
    const now = Date.now();
    for (let effect in playerEffects) {
        if (playerEffects[effect].active && now > playerEffects[effect].endTime) {
            removePowerUpEffect(effect);
        }
    }
}

// æ›´æ–°ç©å®¶è»Šè¼›
function updatePlayerCar() {
    if (keys.ArrowUp && playerCar.speed < playerCar.maxSpeed) {
        playerCar.speed += playerCar.acceleration;
    } else if (keys.ArrowDown && playerCar.speed > 0) {
        playerCar.speed -= playerCar.deceleration * 2;
    } else if (playerCar.speed > 0) {
        playerCar.speed -= playerCar.deceleration;
    } else if (playerCar.speed < 0) {
        playerCar.speed = 0;
    }

    if (keys.ArrowLeft && playerCar.track > 0) {
        playerCar.track--;
        playerCar.x = playerCar.track * trackWidth + (trackWidth - playerCar.width) / 2;
        gameAudio.playLaneChange(); // æ›é“éŸ³æ•ˆ
        keys.ArrowLeft = false;
    } else if (keys.ArrowRight && playerCar.track < trackCount - 1) {
        playerCar.track++;
        playerCar.x = playerCar.track * trackWidth + (trackWidth - playerCar.width) / 2;
        gameAudio.playLaneChange(); // æ›é“éŸ³æ•ˆ
        keys.ArrowRight = false;
    }

    speed = Math.round(playerCar.speed * 10);
    
    // æ›´æ–°è³½é“é€²åº¦
    if (playerCar.speed > 0) {
        trackProgress += (playerCar.speed / maxSpeed) * 0.05; // æ ¹æ“šé€Ÿåº¦æ›´æ–°é€²åº¦
        if (trackProgress >= 100) {
            trackProgress = 0; // å®Œæˆä¸€åœˆ
            currentLap++;
            score += 100; // å®Œæˆåœˆé€Ÿçå‹µ
            gameAudio.playLapComplete(); // åœˆé€Ÿå®ŒæˆéŸ³æ•ˆ
            showFloatingText(canvas.width/2, canvas.height/2, `+100 åœˆé€Ÿçå‹µ!`, '#FFD700');
        }
        if (trackProgress > 100) trackProgress = 100;
    }
}

// æ›´æ–°UI
function updateUI() {
    scoreElement.textContent = score;
    speedElement.textContent = speed + ' km/h';
    livesElement.textContent = lives;
    progressFillElement.style.width = trackProgress + '%';
    lapProgressElement.textContent = Math.floor(trackProgress);
}

// æ›´æ–°ç‹€æ…‹æ•ˆæœ
function updateStatusEffects() {
    statusEffectsElement.innerHTML = '';
    for (let effectKey in playerEffects) {
        const effect = playerEffects[effectKey];
        if (effect.active && POWERUP_TYPES[effectKey]) {
            const powerUpType = POWERUP_TYPES[effectKey];
            const timeLeft = Math.max(0, Math.ceil((effect.endTime - Date.now()) / 1000));
            const effectElement = document.createElement('div');
            effectElement.className = 'status-effect';
            effectElement.innerHTML = `
                <div class="status-effect-icon ${effectKey}-icon"></div>
                <span>${powerUpType.icon} ${powerUpType.name}: ${timeLeft}s</span>
            `;
            statusEffectsElement.appendChild(effectElement);
        }
    }
}

// çµæŸéŠæˆ²
function endGame() {
    gameRunning = false;
    if (gameFrameId) {
        cancelAnimationFrame(gameFrameId);
        gameFrameId = null;
    }
    finalScoreElement.textContent = score;
    gameOverScreen.style.display = 'flex';
}

// éŠæˆ²ä¸»å¾ªç’°
function gameLoop() {
    if (!gameRunning || gamePaused || countDownActive) {
        gameFrameId = requestAnimationFrame(gameLoop);
        return;
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTracks();
    checkEffectsExpiry();
    updateEnemyCars();
    drawEnemyCars();
    updatePowerUps();
    drawPowerUps();
    updatePlayerCar();
    
    // æ·»åŠ é€Ÿåº¦ç·šæ•ˆæœ
    if (playerCar.speed > maxSpeed * 0.8) {
        particleSystem.createSpeedLines(playerCar.x + playerCar.width/2, playerCar.y + playerCar.height);
    }
    
    drawPlayerCar();
    checkCollisions();
    
    // æ›´æ–°å’Œç¹ªè£½ç²’å­æ•ˆæœ
    particleSystem.update();
    particleSystem.draw();

    if (Math.random() < 0.03) {
        generateEnemyCar();
    }
    generatePowerUp();

    updateUI();
    if (Date.now() % 1000 < 16) {
        updateStatusEffects();
    }

    gameFrameId = requestAnimationFrame(gameLoop);
}

// éµç›¤äº‹ä»¶
document.addEventListener('keydown', (e) => {
    if (keys.hasOwnProperty(e.key)) {
        keys[e.key] = true;
        switch(e.key) {
            case 'ArrowUp': keyUp.classList.add('active'); break;
            case 'ArrowDown': keyDown.classList.add('active'); break;
            case 'ArrowLeft': keyLeft.classList.add('active'); break;
            case 'ArrowRight': keyRight.classList.add('active'); break;
        }
    }
});

document.addEventListener('keyup', (e) => {
    if (keys.hasOwnProperty(e.key)) {
        keys[e.key] = false;
        switch(e.key) {
            case 'ArrowUp': keyUp.classList.remove('active'); break;
            case 'ArrowDown': keyDown.classList.remove('active'); break;
            case 'ArrowLeft': keyLeft.classList.remove('active'); break;
            case 'ArrowRight': keyRight.classList.remove('active'); break;
        }
    }
});

// è§¸æ§æ§åˆ¶
let touchStartX = 0;
let touchStartY = 0;
let lastLaneChangeTime = 0;
const laneChangeCooldown = 200;
document.addEventListener('touchstart', (e) => {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    e.preventDefault();
});

document.addEventListener('touchmove', (e) => {
    if (!gameRunning || gamePaused) return;
    const touchX = e.touches[0].clientX;
    const touchY = e.touches[0].clientY;
    const deltaX = touchX - touchStartX;
    const deltaY = touchY - touchStartY;
    const now = Date.now();

    if (Math.abs(deltaX) > 30 && now - lastLaneChangeTime > laneChangeCooldown) {
        if (deltaX > 0 && playerCar.track < trackCount - 1) {
            playerCar.track++;
            playerCar.x = playerCar.track * trackWidth + (trackWidth - playerCar.width) / 2;
            touchStartX = touchX;
            lastLaneChangeTime = now;
        } else if (deltaX < 0 && playerCar.track > 0) {
            playerCar.track--;
            playerCar.x = playerCar.track * trackWidth + (trackWidth - playerCar.width) / 2;
            touchStartX = touchX;
            lastLaneChangeTime = now;
        }
    }

    if (Math.abs(deltaY) > 20) {
        if (deltaY > 0 && playerCar.speed > 0) {
            playerCar.speed -= playerCar.deceleration * 3;
            touchStartY = touchY;
        } else if (deltaY < 0 && playerCar.speed < playerCar.maxSpeed) {
            playerCar.speed += playerCar.acceleration * 2;
            touchStartY = touchY;
        }
    }
    e.preventDefault();
});

// æŒ‰éˆ•äº‹ä»¶
startButton.addEventListener('click', () => {
    gameAudio.playButtonClick(); // æŒ‰éˆ•éŸ³æ•ˆ
    gameAudio.resumeAudio(); // æ¢å¾©éŸ³é »ä¸Šä¸‹æ–‡ï¼ˆç”¨æ–¼ç§»å‹•ç«¯ï¼‰
    if (!gameInitialized) {
        alert('éŠæˆ²è³‡æºå°šæœªå®Œå…¨åŠ è¼‰ï¼Œè«‹ç¨ç­‰...');
        return;
    }
    if (!gameRunning && !countDownActive) {
        startCountdown();
        startButton.textContent = 'é‡æ–°é–‹å§‹';
    } else if (gameOverScreen.style.display === 'flex') {
        startCountdown();
    } else if (gameRunning) {
        gameRunning = false;
        if (gameFrameId) {
            cancelAnimationFrame(gameFrameId);
            gameFrameId = null;
        }
        startCountdown();
    }
});

pauseButton.addEventListener('click', () => {
    gameAudio.playButtonClick(); // æŒ‰éˆ•éŸ³æ•ˆ
    if (gameRunning && !countDownActive) {
        gamePaused = !gamePaused;
        pauseButton.textContent = gamePaused ? 'ç¹¼çºŒéŠæˆ²' : 'æš«åœéŠæˆ²';
        if (!gamePaused) {
            gameLoop();
        }
    }
});

restartButton.addEventListener('click', () => {
    gameAudio.playButtonClick(); // æŒ‰éˆ•éŸ³æ•ˆ
    gameRunning = false;
    if (gameFrameId) {
        cancelAnimationFrame(gameFrameId);
        gameFrameId = null;
    }
    initGame();
    startCountdown();
    gameOverScreen.style.display = 'none';
});

// å€’æ•¸è¨ˆæ™‚
function startCountdown() {
    if (countDownActive) return;
    countDownActive = true;
    countdownOverlay.style.display = 'flex';
    let count = 3;
    countdownNumber.textContent = count;

    const countdownInterval = setInterval(() => {
        count--;
        if (count > 0) {
            countdownNumber.textContent = count;
            gameAudio.playCountdown(count); // å€’æ•¸éŸ³æ•ˆ
        } else {
            clearInterval(countdownInterval);
            countdownOverlay.style.display = 'none';
            countDownActive = false;
            startGame();
        }
    }, 1000);
}

// é–‹å§‹éŠæˆ²
function startGame() {
    gameRunning = true;
    gamePaused = false;
    initGame(); // æœƒè§¸ç™¼ drawInitialScene()
    gameLoop();
}

// æµ®å‹•æ–‡å­—æ•ˆæœ
function showFloatingText(x, y, text, color = '#FFD700') {
    const floatText = document.createElement('div');
    floatText.style.cssText = `
        position: absolute;
        left: ${x}px;
        top: ${y}px;
        color: ${color};
        font-size: 24px;
        font-weight: bold;
        z-index: 1000;
        pointer-events: none;
        animation: floatUp 1.5s ease-out forwards;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    `;
    floatText.textContent = text;
    
    // æ·»åŠ å‹•ç•«CSS
    if (!document.querySelector('#floatTextStyles')) {
        const style = document.createElement('style');
        style.id = 'floatTextStyles';
        style.textContent = `
            @keyframes floatUp {
                0% {
                    transform: translateY(0) scale(0.5);
                    opacity: 0;
                }
                20% {
                    transform: translateY(-10px) scale(1.2);
                    opacity: 1;
                }
                100% {
                    transform: translateY(-60px) scale(1);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    document.querySelector('.game-container').appendChild(floatText);
    setTimeout(() => floatText.remove(), 1500);
}

// ç¹ªè£½å°åœ°åœ–
function drawMiniMap() {
    miniMapCtx.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
    const scale = Math.min(miniMapCanvas.width / canvas.width, miniMapCanvas.height / canvas.height) * 0.8;
    for (let i = 0; i < trackCount; i++) {
        miniMapCtx.fillStyle = trackColors[i];
        miniMapCtx.fillRect(i * trackWidth * scale, 0, trackWidth * scale, miniMapCanvas.height);
    }
    for (let i = 1; i < trackCount; i++) {
        miniMapCtx.fillStyle = '#FFFFFF';
        miniMapCtx.fillRect(i * trackWidth * scale - 2, 0, 4, miniMapCanvas.height);
    }
    miniMapCtx.fillStyle = '#FF416C';
    miniMapCtx.beginPath();
    miniMapCtx.arc(
        (playerCar.x + playerCar.width/2) * scale,
        miniMapCanvas.height - 20,
        8,
        0, Math.PI * 2
    );
    miniMapCtx.fill();
    enemyCars.forEach(car => {
        miniMapCtx.fillStyle = car.color;
        miniMapCtx.beginPath();
        miniMapCtx.arc(
            car.x * scale,
            miniMapCanvas.height - (car.y / canvas.height) * miniMapCanvas.height,
            5,
            0, Math.PI * 2
        );
        miniMapCtx.fill();
    });
    miniMapCtx.fillStyle = '#FFFFFF';
    miniMapCtx.font = '10px Arial';
    miniMapCtx.textAlign = 'center';
    miniMapCtx.fillText('â†‘', miniMapCanvas.width / 2, 15);
}
</script>
</body>
</html>